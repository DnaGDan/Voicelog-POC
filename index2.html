<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Log Interpolator (Prototype)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b0f14; color:#e7eef7; }
    #wrap { display:grid; grid-template-columns: 420px 1fr; height:100vh; }
    #panel { border-right:1px solid rgba(255,255,255,.08); padding:14px; overflow:auto; }
    #panel h1 { font-size:16px; margin:0 0 10px; }
    #panel p, #panel li { color: rgba(231,238,247,.78); line-height:1.35; font-size:13px; }
    textarea { width:100%; min-height:260px; background:#0f1720; color:#e7eef7; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .row { display:flex; gap:10px; align-items:center; margin:10px 0; flex-wrap:wrap; }
    .row > * { flex: 1 1 auto; }
    button {
      background:#1a2633; color:#e7eef7; border:1px solid rgba(255,255,255,.14);
      border-radius:10px; padding:10px 12px; cursor:pointer; font-weight:600;
    }
    button:hover { border-color: rgba(255,255,255,.30); }
    .card { background:#0f1720; border:1px solid rgba(255,255,255,.10); border-radius:12px; padding:10px; margin:10px 0; }
    .kpi { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .kpi div { background:#0b1220; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px; }
    .kpi b { display:block; font-size:12px; color: rgba(231,238,247,.7); }
    .kpi span { font-size:14px; }
    input[type="range"] { width:100%; }
    label { font-size:12px; color: rgba(231,238,247,.70); display:flex; justify-content:space-between; gap:10px; }
    #canvas { position:relative; }
    #hint {
      position:absolute; left:10px; bottom:10px; padding:8px 10px; border-radius:10px;
      background: rgba(10,15,20,.55); border:1px solid rgba(255,255,255,.10); font-size:12px;
      color: rgba(231,238,247,.78);
      pointer-events:none;
    }
    .small { font-size:12px; color: rgba(231,238,247,.68); }
    .pill { display:inline-block; padding:2px 8px; border:1px solid rgba(255,255,255,.14); border-radius:999px; font-size:12px; color:rgba(231,238,247,.78); }
    .warn { color:#ffd27d; }
    .ok { color:#9dffb3; }
  </style>
</head>
<body>
<div id="wrap">
  <div id="panel">
    <h1>3D Log Interpolator (Prototype)</h1>
    <p class="small">
      Paste multiple logs (trial pits / boreholes). This parser is happiest with blocks containing:
      <span class="pill">ID</span> <span class="pill">CO-ORDS</span> <span class="pill">LEVEL (m OD)</span> <span class="pill">Depth (m)</span>.
    </p>

    <div class="card">
      <label>
        <span>Confidence (how much we “fill in the gaps”)</span>
        <span id="confVal" class="pill">0.55</span>
      </label>
      <input id="confidence" type="range" min="0" max="1" step="0.01" value="0.55" />
      <p class="small">
        Low = show only what’s directly supported. High = larger extrapolation radius, more smoothing, bolder surfaces.
      </p>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnDemo">Load demo</button>
        <button id="btnBuild">Build 3D model</button>
        <button id="btnClear">Clear scene</button>
      </div>
      <div class="kpi">
        <div><b>Logs parsed</b><span id="kLogs">0</span></div>
        <div><b>Horizons built</b><span id="kHz">0</span></div>
        <div><b>Points used</b><span id="kPts">0</span></div>
        <div><b>Parse notes</b><span id="kNote" class="warn">-</span></div>
      </div>
    </div>

    <textarea id="input" spellcheck="false" placeholder="Paste logs here..."></textarea>

    <div class="card">
      <p class="small">
        <b>Tips</b>
      </p>
      <ul>
        <li>Keep all logs in one paste. Each should include <span class="pill">Trial Pit Log No.</span> or similar.</li>
        <li>If a log is missing a horizon (shorter pit), confidence controls whether we estimate it from neighbors.</li>
        <li>Surfaces are built as horizons <span class="pill">H1</span>, <span class="pill">H2</span>… (boundary depths in order).</li>
      </ul>
      <p class="small warn">
        This is a prototype: it does not understand faults, lenses, facies changes, “becoming…” text, or geological reality.
        It understands: points + depths + triangulation. Like most software.
      </p>
    </div>
  </div>

  <div id="canvas">
    <div id="hint">Orbit: left-drag · Pan: right-drag · Zoom: wheel</div>
  </div>
</div>

<!-- three.js (non-module build) -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<!-- Delaunay triangulation -->
<script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>

<script>
  // -----------------------------
  // Utilities
  // -----------------------------
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;

  function parseFloats(str) {
    const m = str.match(/-?\d+(\.\d+)?/g);
    return m ? m.map(Number) : [];
  }

  function dist2(ax, ay, bx, by) {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  }

  // Inverse Distance Weighting
  function idwEstimate(x, y, samples, power=2) {
    let num = 0, den = 0;
    for (const s of samples) {
      const d2 = dist2(x,y,s.x,s.y);
      if (d2 < 1e-12) return s.z;
      const w = 1 / Math.pow(Math.sqrt(d2), power);
      num += w * s.z;
      den += w;
    }
    return den > 0 ? num/den : null;
  }

  function median(values) {
    if (!values.length) return null;
    const a = values.slice().sort((x,y)=>x-y);
    const mid = Math.floor(a.length/2);
    return a.length % 2 ? a[mid] : 0.5*(a[mid-1]+a[mid]);
  }

  // -----------------------------
  // Parsing
  // -----------------------------
  /**
   * Attempts to parse trial pit/borehole blocks from pasted text.
   *
   * Expected-ish patterns (loosely):
   *  - "Trial Pit Log No. TP01"
   *  - "CO-ORDS: 305661E, 380994N"
   *  - "LEVEL: 14.18m OD"
   *  - "Depth (m) 0.10 2.70"  (multiple numbers = boundaries + end depth)
   */
  function parseLogs(raw) {
    const text = raw.replace(/\u00A0/g, " ").replace(/[ \t]+/g, " ");
    const blocks = text.split(/(?:\n|\r|\r\n)\s*Trial Pit Log\s*No\.?/i)
                       .map(s => s.trim())
                       .filter(Boolean);

    // If the user pasted without the "Trial Pit Log No." prefix,
    // fallback to splitting on "No." lines.
    const candidateBlocks = blocks.length ? blocks : text.split(/\bTP\d{2}\b/).map(s=>s.trim()).filter(Boolean);

    const logs = [];
    const notes = [];

    for (const b of candidateBlocks) {
      // ID
      const idMatch = b.match(/\b(TP\d{2})\b/i) || b.match(/\b(BH\d{2,})\b/i);
      const id = idMatch ? idMatch[1].toUpperCase() : null;

      // Coords
      // Handles "305661E, 380994N" or "305661 E, 380994 N"
      const coordMatch = b.match(/CO-?ORDS:\s*([0-9]{5,7})\s*E[, ]\s*([0-9]{5,7})\s*N/i)
                      || b.match(/\b([0-9]{5,7})\s*E[, ]\s*([0-9]{5,7})\s*N\b/i);
      const x = coordMatch ? Number(coordMatch[1]) : null;
      const y = coordMatch ? Number(coordMatch[2]) : null;

      // Level (m OD)
      const levelMatch = b.match(/LEVEL:\s*([0-9]+(?:\.[0-9]+)?)\s*m\s*OD/i)
                      || b.match(/LEVEL:\s*([0-9]+(?:\.[0-9]+)?)\s*OD/i);
      const levelOD = levelMatch ? Number(levelMatch[1]) : null;

      // Depth list
      // We try to grab the section after "Depth (m)" until "Level" or "Legend"
      let depthList = [];
      const depthSection = b.match(/Depth\s*\(m\)([\s\S]*?)(?:Level|Legend|Trial Pit Log|Remarks)/i);
      if (depthSection) {
        depthList = parseFloats(depthSection[1])
          .filter(v => v >= 0 && v < 200) // sanity
          .slice(0, 30);
      }

      // If depthList looks empty, try a simpler scan for a short list of depths near the top
      if (depthList.length < 1) {
        const quick = b.match(/\bDepth\s*\(m\)\b([\s\S]*?)\n/i);
        if (quick) depthList = parseFloats(quick[1]).filter(v=>v>=0 && v<200).slice(0, 30);
      }

      // We interpret depthList as boundary depths in order, last value typically = end depth.
      // Strata count = depthList.length (from 0 -> d1, d1->d2, ...).
      if (!id || x === null || y === null || levelOD === null || depthList.length < 1) {
        // skip empty junk blocks, but keep a note if it looked close
        if (id || coordMatch || levelMatch) {
          notes.push(`Could not fully parse a log block (id:${id||"?"} coords:${coordMatch?"yes":"no"} level:${levelMatch?"yes":"no"} depths:${depthList.length}).`);
        }
        continue;
      }

      logs.push({
        id, x, y, levelOD,
        depthsBgl: depthList
      });
    }

    // Deduplicate by id (last one wins)
    const map = new Map();
    for (const l of logs) map.set(l.id, l);
    const out = Array.from(map.values());

    return { logs: out, notes };
  }

  // -----------------------------
  // 3D Viewer setup (Three.js)
  // -----------------------------
  let renderer, scene, camera, controls;
  let rootGroup = new THREE.Group();
  let gridHelper, axesHelper;
  const canvasHost = $("canvas");

  function init3D() {
    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(canvasHost.clientWidth, canvasHost.clientHeight);
    canvasHost.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    camera = new THREE.PerspectiveCamera(55, canvasHost.clientWidth/canvasHost.clientHeight, 0.1, 1e7);
    camera.position.set(0, 800, 1200);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;

    // Lighting
    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.85);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.55);
    dir.position.set(600, 900, 400);
    scene.add(dir);

    // Helpers
    gridHelper = new THREE.GridHelper(2000, 40, 0x3a4b5c, 0x1f2a35);
    gridHelper.position.y = 0;
    scene.add(gridHelper);

    axesHelper = new THREE.AxesHelper(300);
    scene.add(axesHelper);

    scene.add(rootGroup);

    window.addEventListener("resize", onResize);
    animate();
  }

  function onResize() {
    if (!renderer) return;
    renderer.setSize(canvasHost.clientWidth, canvasHost.clientHeight);
    camera.aspect = canvasHost.clientWidth/canvasHost.clientHeight;
    camera.updateProjectionMatrix();
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  function clearScene() {
    while (rootGroup.children.length) {
      const o = rootGroup.children.pop();
      o.traverse?.(n => {
        if (n.geometry) n.geometry.dispose?.();
        if (n.material) {
          if (Array.isArray(n.material)) n.material.forEach(m=>m.dispose?.());
          else n.material.dispose?.();
        }
      });
    }
    $("kHz").textContent = "0";
    $("kPts").textContent = "0";
  }

  // -----------------------------
  // Building horizons
  // -----------------------------
  /**
   * Build triangulated surface from scattered points.
   * Points: [{x,y,z}]
   * Returns THREE.Mesh
   */
  function buildSurfaceMesh(points, opts) {
    if (points.length < 3) return null;

    // Delaunay in XY
    const coords = new Float64Array(points.length * 2);
    for (let i=0;i<points.length;i++) {
      coords[2*i] = points[i].x;
      coords[2*i+1] = points[i].y;
    }

    const delaunay = Delaunator.from(coords);
    const tris = delaunay.triangles; // indices

    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(points.length * 3);
    for (let i=0;i<points.length;i++) {
      positions[3*i] = points[i].x;
      positions[3*i+1] = points[i].z;
      positions[3*i+2] = points[i].y;
    }
    geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    // Cull "stupid triangles" (overly long edges) to reduce wild bridging.
    // Threshold scales with site extent.
    const maxEdge = opts.maxEdge || 1e9;
    const keep = [];
    for (let t=0; t<tris.length; t+=3) {
      const a = tris[t], b = tris[t+1], c = tris[t+2];
      const pa = points[a], pb = points[b], pc = points[c];
      const ab = Math.sqrt(dist2(pa.x,pa.y,pb.x,pb.y));
      const bc = Math.sqrt(dist2(pb.x,pb.y,pc.x,pc.y));
      const ca = Math.sqrt(dist2(pc.x,pc.y,pa.x,pa.y));
      if (ab<=maxEdge && bc<=maxEdge && ca<=maxEdge) {
        keep.push(a,b,c);
      }
    }

    geom.setIndex(keep);
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({
      color: opts.color,
      transparent: true,
      opacity: opts.opacity,
      side: THREE.DoubleSide,
      roughness: 0.95,
      metalness: 0.0
    });

    const mesh = new THREE.Mesh(geom, mat);
    return mesh;
  }

  function addPoints(logs, center) {
    const g = new THREE.Group();
    const geom = new THREE.SphereGeometry(8, 16, 12);
    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
    for (const l of logs) {
      const m = new THREE.Mesh(geom, mat);
      m.position.set(l.x - center.x, l.levelOD - center.z, l.y - center.y);
      g.add(m);
    }
    rootGroup.add(g);
  }

  function buildModelFromLogs(logs, confidence) {
    clearScene();
    if (!logs.length) return;

    // Normalize XY around center for nicer numbers
    const cx = median(logs.map(l=>l.x));
    const cy = median(logs.map(l=>l.y));
    const cz = median(logs.map(l=>l.levelOD));
    const center = { x:cx, y:cy, z:cz };

    // Compute site extent for thresholds
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for (const l of logs) {
      minX = Math.min(minX, l.x);
      maxX = Math.max(maxX, l.x);
      minY = Math.min(minY, l.y);
      maxY = Math.max(maxY, l.y);
    }
    const extent = Math.max(maxX-minX, maxY-minY) || 1;

    // Confidence mapping
    const fillRadius = lerp(0.15*extent, 0.90*extent, confidence);       // neighbor search radius
    const maxEdge = lerp(0.20*extent, 0.80*extent, confidence);          // allow longer triangles if confident
    const smoothK = lerp(0.0, 0.65, confidence);                         // smoothing
    const baseOpacity = lerp(0.22, 0.55, confidence);

    // Determine maximum horizon count across logs
    const maxH = Math.max(...logs.map(l => l.depthsBgl.length));

    // Add point markers at ground level
    addPoints(logs, center);

    // Build each horizon surface Hi (base of stratum i)
    let horizonsBuilt = 0;
    let pointsUsedTotal = 0;

    for (let hi=0; hi<maxH; hi++) {
      // Gather observed points for this horizon
      const observed = [];
      const missing = [];
      for (const l of logs) {
        const d = l.depthsBgl[hi];
        if (typeof d === "number" && isFinite(d)) {
          const z = l.levelOD - d; // elevation of boundary
          observed.push({ x: l.x, y: l.y, z });
        } else {
          missing.push(l);
        }
      }

      // If too few observed, skip
      if (observed.length < 3) continue;

      // Optionally fill missing using IDW from neighbors within radius
      const filled = observed.slice();
      if (missing.length && confidence > 0.05) {
        const r2 = fillRadius * fillRadius;
        for (const l of missing) {
          // find neighbor samples within radius
          const near = [];
          for (const s of observed) {
            if (dist2(l.x,l.y,s.x,s.y) <= r2) near.push(s);
          }
          if (near.length >= 3) {
            const est = idwEstimate(l.x, l.y, near, 2);
            if (est !== null) filled.push({ x:l.x, y:l.y, z:est, _filled:true });
          }
        }
      }

      // Simple smoothing pass (blend towards local IDW)
      if (smoothK > 0.0001) {
        const r2 = (0.35*extent) * (0.35*extent);
        const smoothed = filled.map(p => ({...p}));
        for (let i=0;i<filled.length;i++) {
          const p = filled[i];
          const near = [];
          for (let j=0;j<filled.length;j++) {
            if (i===j) continue;
            const q = filled[j];
            if (dist2(p.x,p.y,q.x,q.y) <= r2) near.push(q);
          }
          if (near.length >= 3) {
            const est = idwEstimate(p.x,p.y,near,2);
            if (est !== null) smoothed[i].z = lerp(p.z, est, smoothK);
          }
        }
        filled.length = 0;
        filled.push(...smoothed);
      }

      // Create mesh in centered coordinates
      const ptsCentered = filled.map(p => ({
        x: p.x - center.x,
        y: p.y - center.y,
        z: p.z - center.z
      }));

      // Color ramp per horizon
      const hue = (hi / Math.max(1, maxH-1));
      const color = new THREE.Color().setHSL(0.60 - 0.55*hue, 0.55, 0.52);

      const mesh = buildSurfaceMesh(ptsCentered, {
        color,
        opacity: baseOpacity,
        maxEdge
      });

      if (!mesh) continue;

      mesh.name = `H${hi+1}`;
      rootGroup.add(mesh);

      // Add a simple label-ish via console (kept minimal; real labels = sprites or CSS2D)
      horizonsBuilt++;
      pointsUsedTotal += ptsCentered.length;
    }

    // Place grid at median ground level
    gridHelper.position.y = 0;

    // Frame camera
    const box = new THREE.Box3().setFromObject(rootGroup);
    const size = new THREE.Vector3();
    box.getSize(size);
    const center3 = new THREE.Vector3();
    box.getCenter(center3);

    controls.target.copy(center3);
    const maxDim = Math.max(size.x, size.y, size.z) || 1000;
    camera.position.set(center3.x + 0.9*maxDim, center3.y + 0.7*maxDim, center3.z + 0.9*maxDim);
    camera.near = 0.1;
    camera.far = Math.max(1e6, maxDim * 20);
    camera.updateProjectionMatrix();

    $("kHz").textContent = String(horizonsBuilt);
    $("kPts").textContent = String(pointsUsedTotal);
  }

  // -----------------------------
  // Demo data similar to TP logs
  // -----------------------------
  const demoText = `
Trial Pit Log
No.
TP01
PROJECT NO: C6347 CO-ORDS: 305661E, 380994N
LEVEL: 14.18m OD
Depth (m)
0.10
2.70
Legend Stratum Description
Grass over dark brown slightly gravelly slightly sandy clay ... (TOPSOIL).
Firm brown mottled grey slightly gravelly sandy CLAY ... End of Trial Pit at 2.70m

Trial Pit Log
No.
TP02
PROJECT NO: C6347 CO-ORDS: 305710E, 380940N
LEVEL: 21.26m OD
Depth (m)
0.20
1.20
3.00
Legend Stratum Description
Grass over dark brown ... (TOPSOIL).
Firm brown mottled grey ... CLAY ...
Orangish brown ... SAND ... End of Trial Pit at 3.00m

Trial Pit Log
No.
TP03
PROJECT NO: C6347 CO-ORDS: 305680E, 380920N
LEVEL: 21.34m OD
Depth (m)
0.20
1.30
2.60
2.80
Legend Stratum Description
Grass over ... (TOPSOIL).
Firm brown mottled grey ... CLAY ...
Orangish brown ... SAND ...
Stiff brown mottled grey ... CLAY ... End of Trial Pit at 2.80m

Trial Pit Log
No.
TP05
PROJECT NO: C6347 CO-ORDS: 305614E, 380969N
LEVEL: 14.24m OD
Depth (m)
0.30
3.20
Legend Stratum Description
Grass over ... (TOPSOIL).
Soft brown mottled grey ... CLAY ... End of Trial Pit at 3.20m
`.trim();

  // -----------------------------
  // UI wiring
  // -----------------------------
  function refreshConfidenceLabel() {
    const v = Number($("confidence").value);
    $("confVal").textContent = v.toFixed(2);
    return v;
  }

  $("confidence").addEventListener("input", () => {
    refreshConfidenceLabel();
  });

  $("btnDemo").addEventListener("click", () => {
    $("input").value = demoText;
    $("kNote").textContent = "Demo loaded";
    $("kNote").className = "ok";
  });

  $("btnBuild").addEventListener("click", () => {
    const conf = refreshConfidenceLabel();
    const raw = $("input").value.trim();
    const { logs, notes } = parseLogs(raw);

    $("kLogs").textContent = String(logs.length);
    if (!logs.length) {
      $("kNote").textContent = "No logs parsed. Paste more complete text.";
      $("kNote").className = "warn";
      return;
    }

    $("kNote").textContent = notes.length ? notes[0] : "Parsed OK";
    $("kNote").className = notes.length ? "warn" : "ok";

    buildModelFromLogs(logs, conf);
  });

  $("btnClear").addEventListener("click", () => {
    clearScene();
    $("kNote").textContent = "-";
    $("kNote").className = "warn";
  });

  // Boot
  init3D();
  refreshConfidenceLabel();
</script>
</body>
</html>
