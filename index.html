<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Voice-first Geo Logging PoC (v4)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display: grid; grid-template-columns: minmax(0, 2fr) minmax(0, 1fr); gap: 12px; align-items: start; }
    .stack { display: grid; gap: 12px; align-content: start; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    textarea { width: 100%; min-height: 120px; border-radius: 10px; border: 1px solid #ccc; padding: 10px; }
    pre { background: #0b1020; color: #e6e6e6; padding: 10px; border-radius: 10px; overflow: auto; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #ccc; margin-right: 6px; font-size: 12px; margin-bottom: 6px; }
    .warn { border-color: #c97; }
    .ok { border-color: #8c8; }
    .muted { color: #666; font-size: 13px; }
    .list { display: grid; gap: 8px; }
    .small { font-size: 12px; color: #666; }
    .debug { white-space: pre-wrap; background:#fff7e6; border:1px solid #f0d39a; padding:10px; border-radius:10px; }
    select { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    input { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    .row3 { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .meter { width: 160px; height: 10px; border-radius: 999px; background: #eee; border: 1px solid #ccc; overflow: hidden; }
    .meter-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #6ab04c, #f9ca24, #eb4d4b); transition: width 0.08s linear; }
    .progress { width: 180px; height: 10px; border-radius: 999px; background: #eee; border: 1px solid #ccc; overflow: hidden; }
    .progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #1e90ff, #6ab04c); transition: width 0.2s linear; }
    .progress-fill.running { width: 45%; transform: translateX(-120%); animation: progressMove 1.1s ease-in-out infinite; }
    .log-wrap { border: 1px solid #eee; border-radius: 12px; padding: 8px; background: #fafafa; }
    .log-svg { width: 100%; height: 1560px; display: block; background: #fff; border-radius: 10px; border: 1px solid #eee; }
    .log-legend { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .review-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .review-table th, .review-table td { border: 1px solid #ddd; padding: 6px; vertical-align: top; }
    .review-table th { background: #f5f5f5; text-align: left; }
    .review-muted { color: #666; font-size: 12px; }
    .review-badge { display:inline-block; padding:2px 6px; border-radius: 6px; border:1px solid #ccc; font-size:11px; }
    .chat-thread { border: 1px solid #eee; border-radius: 12px; padding: 12px; background: #fff; display: flex; flex-direction: column; gap: 10px; max-height: 360px; overflow-y: auto; }
    .chat-message { display: flex; }
    .chat-message.user { justify-content: flex-start; }
    .chat-message.assistant { justify-content: flex-start; }
    .chat-bubble { max-width: 75%; padding: 8px 10px; border-radius: 12px; white-space: pre-wrap; }
    .chat-message.user .chat-bubble { background: #111; color: #fff; border-radius: 12px 12px 12px 4px; }
    .chat-message.assistant .chat-bubble { background: #f2f2f2; color: #111; border: 1px solid #e0e0e0; border-radius: 12px 12px 12px 4px; }
    .chat-empty { color: #666; font-size: 13px; }
    .chat-thread + textarea { margin-top: 8px; }
    @keyframes progressMove { 0% { transform: translateX(-120%); } 100% { transform: translateX(220%); } }
    @media (max-width: 900px) { .row { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <h2>Voice-first Geo Logging PoC (v4)</h2>
  <p class="muted">
    This version can use an online LLM with an API key, or fall back to rules-only parsing.
  </p>

  <div class="card" style="margin-bottom:12px;">
    <h3>0) Online LLM</h3>
    <div class="row3" style="margin-bottom:8px;">
      <label class="small" for="remoteModel"><strong>Online model</strong></label>
      <select id="remoteModel">
        <option value="gpt-4o-mini">GPT-4o mini (fast)</option>
        <option value="gpt-4o">GPT-4o (best)</option>
        <option value="gpt-4.1-mini">GPT-4.1 mini</option>
        <option value="gpt-4.1">GPT-4.1</option>
      </select>
      <label class="small" for="remoteApiKey"><strong>API key</strong></label>
      <input id="remoteApiKey" type="password" autocomplete="off" placeholder="sk-..." style="min-width:240px;">
      <label class="small" for="remoteBase"><strong>API base</strong></label>
      <input id="remoteBase" type="text" value="https://api.openai.com/v1" style="min-width:240px;">
      <button id="btnEnableRemote" type="button">Enable online</button>
      <button id="btnDisableRemote" type="button" disabled>Disable online</button>
    </div>
    <div class="small" id="remoteStatus">Online: disabled</div>
    <div class="small muted">ChatGPT sign-in is not available in-browser. Use an API key or a proxy server.</div>
  </div>

  <div class="row">
    <div class="stack">
      <div class="card">
      <h3>1) Conversation</h3>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">
        <button id="btnStart" class="primary" type="button">Start voice</button>
        <button id="btnStop" type="button" disabled>Stop</button>
        <button id="btnMicTest" type="button">Mic test</button>
        <button id="btnClear" type="button">Clear</button>
      </div>
      <div class="row3" style="margin-bottom:8px;">
        <label class="small" for="entryType"><strong>Entry type</strong></label>
        <select id="entryType">
          <option value="auto">Auto</option>
          <option value="strata">Strata</option>
          <option value="sample">Sample</option>
          <option value="water">Water</option>
          <option value="test">In-situ test</option>
          <option value="note">Note</option>
        </select>
        <label class="small" for="holeId"><strong>Hole ID</strong></label>
        <input id="holeId" type="text" value="EH1"/>
      </div>
      <div class="small muted" style="margin-top:6px;">Conversation</div>
      <div id="chatThread" class="chat-thread" aria-live="polite"></div>
      <textarea id="txtTranscript" placeholder="Type your next message here. e.g. 'Second layer is not topsoil; it is firm sandy clay.'"></textarea>
      <div class="row3" style="margin-top:8px;">
        <div class="meter" aria-label="Mic level"><div id="micLevel" class="meter-fill"></div></div>
        <div class="small" id="micStatus">Mic: idle</div>
      </div>
      <div class="row3" style="margin-top:6px;">
        <label class="small"><input id="autoAnalyzeVoice" type="checkbox"> Auto-analyze on stop (uses online if enabled)</label>
      </div>
      <div class="row3" style="margin-top:6px;">
        <label class="small"><input id="useOpenAiTranscription" type="checkbox"> Use OpenAI transcription</label>
        <label class="small" for="transcribeModel"><strong>Transcribe model</strong></label>
        <select id="transcribeModel">
          <option value="gpt-4o-mini-transcribe">gpt-4o-mini-transcribe</option>
          <option value="gpt-4o-transcribe">gpt-4o-transcribe</option>
          <option value="whisper-1">whisper-1</option>
        </select>
      </div>
      <div class="small" id="transcribeStatus">Transcription: browser</div>
      <div class="muted" id="status">Status: idle</div>
      <div class="small" id="diag"></div>
      </div>

      <div class="card">
      <h3>2) Extract + prompt</h3>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">
        <button id="btnAnalyze" class="primary" type="button">Analyze (best guess)</button>
        <button id="btnConfirm" type="button" disabled>Confirm entry</button>
        <button id="btnExport" type="button" disabled>Export JSON</button>
      </div>
      <div class="row3" style="margin-bottom:8px;">
        <div class="progress" aria-label="AI analysis progress"><div id="aiProgress" class="progress-fill"></div></div>
        <div class="small" id="aiStatus">AI: idle</div>
        <button id="btnCancelAI" type="button" disabled>Cancel AI</button>
      </div>

      <div id="pills"></div>
      <h4>Prompts</h4>
      <div class="list" id="prompts"></div>
      <h4>Follow-up questions</h4>
      <div class="list" id="followups"></div>
      <h4>Review</h4>
      <div id="review" class="review-muted">Nothing to review yet.</div>
    </div>
  </div>

    <div class="card">
      <h3>Exploratory hole log</h3>
      <div class="log-wrap">
        <svg id="logSvg" class="log-svg" viewBox="0 0 700 520" role="img" aria-label="Exploratory hole log"></svg>
      </div>
      <div class="log-legend small">
        <span class="pill ok">Strata</span>
        <span class="pill">Sample</span>
        <span class="pill">Water</span>
        <span class="pill">Test</span>
      </div>
      <div class="small muted">Log updates when you confirm an entry.</div>
      <pre id="logData" style="margin-top:8px;">{}</pre>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <h3>Structured output</h3>
    <pre id="out">{}</pre>
  </div>

  <div class="card" style="margin-top:12px;">
    <h3>Confirmed entries</h3>
    <div class="row3" style="margin-bottom:8px;">
      <button id="btnCancelEdit" type="button" disabled>Cancel edit</button>
      <button id="btnClearDb" type="button">Clear database</button>
    </div>
    <div class="list" id="entryList"></div>
    <pre id="entries">[]</pre>
  </div>

  <div class="card" style="margin-top:12px;">
    <h3>Debug</h3>
    <div class="debug" id="debug">Loading.</div>
  </div>

<script type="module">

  const $ = (id) => document.getElementById(id);
  const debug = (msg) => {
    const el = $("debug");
    el.textContent = (el.textContent === "Loading." ? "" : el.textContent + "\\n") + msg;
  };

  window.addEventListener("error", (e) => {
    debug("JS ERROR: " + (e.message || e.type) + " @ " + (e.filename || "") + ":" + (e.lineno || "") );
  });
  window.addEventListener("unhandledrejection", (e) => {
    debug("PROMISE REJECTION: " + (e.reason?.message || String(e.reason)));
  });

  // ---------------- State ----------------
  const state = {
    current: null,
    entries: [],
    editIndex: null,
    chat: [],
    log: {
      hole_id: "EH1",
      strata: [],
      samples: [],
      water: [],
      tests: [],
      notes: []
    }
  };
  const aiState = {
    inFlight: false,
    canceled: false,
    requestId: 0,
    lastLocal: null,
    abortController: null,
    pendingFollowups: []
  };
  const remoteState = {
    enabled: false,
    apiKey: "",
    model: "gpt-4.1",
    baseUrl: "https://api.openai.com/v1"
  };
  const DB_NAME = "voicelog-poc";
  const DB_VERSION = 1;
  const DB_STORE = "state";
  const storageState = { db: null, saveTimer: null };

  function openLogDb() {
    if (!("indexedDB" in window)) return Promise.resolve(null);
    if (storageState.db) return Promise.resolve(storageState.db);
    return new Promise((resolve) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE);
      };
      req.onsuccess = () => {
        storageState.db = req.result;
        resolve(storageState.db);
      };
      req.onerror = () => {
        debug("IndexedDB unavailable: " + (req.error?.message || req.error || "unknown"));
        resolve(null);
      };
    });
  }

  function schedulePersist(reason) {
    if (!("indexedDB" in window)) return;
    if (storageState.saveTimer) clearTimeout(storageState.saveTimer);
    storageState.saveTimer = setTimeout(() => {
      storageState.saveTimer = null;
      persistState(reason);
    }, 250);
  }

  async function persistState(reason) {
    const db = await openLogDb();
    if (!db) return;
    const payload = {
      log: state.log,
      entries: state.entries,
      saved_at: new Date().toISOString(),
      reason: reason || ""
    };
    await new Promise((resolve) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put(payload, "log");
      tx.oncomplete = () => resolve();
      tx.onerror = () => resolve();
    });
  }

  function normalizeStoredLog(log) {
    const safe = {
      hole_id: (typeof log?.hole_id === "string" && log.hole_id.trim()) ? log.hole_id.trim() : state.log.hole_id,
      strata: Array.isArray(log?.strata) ? log.strata : [],
      samples: Array.isArray(log?.samples) ? log.samples : [],
      water: Array.isArray(log?.water) ? log.water : [],
      tests: Array.isArray(log?.tests) ? log.tests : [],
      notes: Array.isArray(log?.notes) ? log.notes : []
    };
    ensureHorizonIds(safe.strata);
    return safe;
  }

  async function restoreStateFromStorage() {
    const db = await openLogDb();
    if (!db) return;
    const payload = await new Promise((resolve) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get("log");
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => resolve(null);
    });
    if (!payload) return;
    if (payload.log) state.log = normalizeStoredLog(payload.log);
    if (Array.isArray(payload.entries)) state.entries = payload.entries;
    debug("Restored log context from IndexedDB.");
  }

  function clearDatabase() {
    const ok = confirm("Clear saved log context and confirmed entries? This cannot be undone.");
    if (!ok) return;
    if (storageState.saveTimer) {
      clearTimeout(storageState.saveTimer);
      storageState.saveTimer = null;
    }
    if ("indexedDB" in window) {
      if (storageState.db) {
        storageState.db.close();
        storageState.db = null;
      }
      const req = indexedDB.deleteDatabase(DB_NAME);
      req.onsuccess = () => debug("IndexedDB cleared.");
      req.onerror = () => debug("IndexedDB clear failed: " + (req.error?.message || req.error || "unknown"));
    }
    state.entries = [];
    state.current = null;
    state.editIndex = null;
    state.log = { hole_id: "EH1", strata: [], samples: [], water: [], tests: [], notes: [] };
    clearAll();
    $("holeId").value = state.log.hole_id;
    $("entries").textContent = "[]";
    $("btnExport").disabled = true;
    renderEntryList();
    renderLogData();
    renderLog();
    setDiag("Cleared saved log context.");
  }
  const setStatus = (msg) => { $("status").textContent = "Status: " + msg; };
  const setDiag = (msg) => { $("diag").textContent = msg || ""; };
  const setMicStatus = (msg) => {
    const el = $("micStatus");
    if (el) el.textContent = msg || "";
  };
  const setAiStatus = (msg) => {
    const el = $("aiStatus");
    if (el) el.textContent = msg || "";
  };
  const setRemoteStatus = (msg) => {
    const el = $("remoteStatus");
    if (el) el.textContent = "Online: " + (msg || "");
  };
  const setMicLevel = (pct) => {
    const el = $("micLevel");
    if (!el) return;
    const clamped = Math.max(0, Math.min(100, pct));
    el.style.width = clamped.toFixed(0) + "%";
  };
  const setAiProgressRunning = (running) => {
    const el = $("aiProgress");
    if (!el) return;
    if (running) el.classList.add("running");
    else el.classList.remove("running");
    if (!running) el.style.width = "0%";
  };
  const setAiButtons = (enabled) => {
    const cancelAI = $("btnCancelAI");
    if (cancelAI) cancelAI.disabled = !enabled;
  };
  const beginAiRun = () => {
    aiState.inFlight = true;
    aiState.canceled = false;
    aiState.abortController = null;
    setAiStatus("AI: running");
    setAiProgressRunning(true);
    setAiButtons(true);
  };
  const endAiRun = (statusText) => {
    aiState.inFlight = false;
    aiState.abortController = null;
    setAiProgressRunning(false);
    setAiButtons(false);
    setAiStatus(statusText || "AI: idle");
  };
  const cancelAiRun = (reason) => {
    if (!aiState.inFlight) return;
    aiState.canceled = true;
    aiState.inFlight = false;
    if (aiState.abortController) {
      aiState.abortController.abort();
      aiState.abortController = null;
    }
    setAiProgressRunning(false);
    setAiButtons(false);
    setAiStatus(reason || "AI: canceled");
    if (aiState.lastLocal) {
      state.current = aiState.lastLocal;
      $("out").textContent = JSON.stringify(state.current, null, 2);
      renderPillsFromParsed(state.current.parsed);
      renderPrompts(state.current.prompts || []);
      clearPendingFollowups();
      renderFollowups([]);
      renderReview(state.current.parsed);
    }
  };

  // ---------------- Basic rules parsing ----------------
  const normalizeText = (s) => (s || "").trim().replace(/\s+/g, " ");

  function truncateText(text, maxLen) {
    const s = normalizeText(text || "");
    if (!maxLen || s.length <= maxLen) return s;
    return s.slice(0, Math.max(0, maxLen - 3)) + "...";
  }

  function formatDepthValue(v) {
    if (typeof v !== "number" || !isFinite(v)) return "?";
    const s = v.toFixed(2);
    return s.replace(/\.00$/, ".0").replace(/(\.\d)0$/, "$1");
  }

  function formatDepthRange(from, to) {
    return formatDepthValue(from) + "-" + formatDepthValue(to) + " m";
  }

  function formatDepthSingle(depth) {
    return formatDepthValue(depth) + " m";
  }
  const isFiniteNumber = (v) => typeof v === "number" && isFinite(v);

  function preprocessTranscript(text) {
    let t = (text || "").toLowerCase();
    t = t.replace(/[--]/g, "-");
    t = t.replace(/\b(ground\s*level|gl|surface\s*level|surface|ground\s*surface)\b/g, "0.0");
    t = t.replace(/\beoh\b/g, "end of hole");
    // numeric "point 8" -> "0.8"
    t = t.replace(/\bpoint\s+(\d+)\b/g, "0.$1");

    const wordToDigit = {
      zero: "0", one: "1", two: "2", three: "3", four: "4",
      five: "5", six: "6", seven: "7", eight: "8", nine: "9"
    };
    // "point eight" -> "0.8"
    t = t.replace(/\bpoint\s+(zero|one|two|three|four|five|six|seven|eight|nine)\b/g,
      (_, w) => "0." + wordToDigit[w]
    );
    // "two point five" -> "2.5"
    t = t.replace(
      /\b(zero|one|two|three|four|five|six|seven|eight|nine)\s+point\s+(zero|one|two|three|four|five|six|seven|eight|nine)\b/g,
      (_, a, b) => wordToDigit[a] + "." + wordToDigit[b]
    );
    return t;
  }

  function extractDepthsSingle(text) {
    const t = preprocessTranscript(text);

    const m0 = t.match(/\bfrom\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\s+(?:to|down\s+to)\s+end\s+of\s+hole\s+at\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m0) return { from: parseFloat(m0[1]), to: parseFloat(m0[2]), basis: "from-to end of hole" };

    const m0b = t.match(/\bbetween\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\s+and\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m0b) return { from: parseFloat(m0b[1]), to: parseFloat(m0b[2]), basis: "between phrase" };

    const m0c = t.match(/\bto\s+end\s+of\s+hole\s+at\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m0c) return { from: null, to: parseFloat(m0c[1]), basis: "to end of hole" };

    const m0d = t.match(/\bend\s+of\s+hole\s+(?:at\s+)?(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m0d) return { from: null, to: parseFloat(m0d[1]), basis: "end of hole" };

    const m1 = t.match(/\bfrom\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\s+(?:to|down\s+to)\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m1) return { from: parseFloat(m1[1]), to: parseFloat(m1[2]), basis: "from-to phrase" };

    const m1b = t.match(/\b(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\s+(?:to|down\s+to)\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m1b) return { from: parseFloat(m1b[1]), to: parseFloat(m1b[2]), basis: "X to Y phrase" };

    const m2 = t.match(/\b(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\s*-\s*(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m2) return { from: parseFloat(m2[1]), to: parseFloat(m2[2]), basis: "range hyphen" };

    const m3 = t.match(/\b(?:to|down\s+to)\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m3) return { from: null, to: parseFloat(m3[1]), basis: "to-only phrase" };

    return { from: null, to: null, basis: "none" };
  }

  function extractDepthMarker(text) {
    const t = preprocessTranscript(text);
    const m1 = t.match(/\b(?:at|@|depth|around|approx(?:imately)?|about)\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/);
    if (m1) return { depth: parseFloat(m1[1]), basis: "at/depth phrase" };

    const m2 = t.match(/\b(\d+(?:\.\d+)?)\s*(?:m|metres|meters)\s*(?:bgl|below\s+ground\s+level|depth)\b/);
    if (m2) return { depth: parseFloat(m2[1]), basis: "bgl phrase" };

    const m3 = t.match(/\b(\d+(?:\.\d+)?)\s*(?:m|metres|meters)\b/);
    if (m3) return { depth: parseFloat(m3[1]), basis: "number m" };

    return { depth: null, basis: "none" };
  }

  function guessMaterial(text) {
    const t = text.toLowerCase();
    const materials = [];
    const rules = [
      ["made ground", /\bmade\s+ground\b|\bfill\b/],
      ["topsoil", /\btop\s*soil\b|\btopsoil\b/],
      ["clay", /\bclay\b/],
      ["silt", /\bsilt\b/],
      ["sand", /\bsand\b/],
      ["gravel", /\bgravel\b/],
      ["cobbles", /\bcobble(?:s)?\b/],
      ["boulders", /\bboulder(?:s)?\b/],
      ["chalk", /\bchalk\b/],
      ["peat", /\bpeat\b/],
      ["rock", /\bbedrock\b|\brock\b|\bsandstone\b|\blimestone\b|\bgranite\b|\bshale\b|\bmudstone\b|\bsiltstone\b|\bbasalt\b/],
    ];
    for (const [name, re] of rules) if (re.test(t)) materials.push(name);
    return materials.length ? materials : ["unknown"];
  }

  function detectNegatedMaterials(text) {
    const t = (text || "").toLowerCase();
    const negated = new Set();
    const re = /\b(?:not|no|isn't|isnt)\s+(?:a|an)?\s*(made\s+ground|fill|top\s*soil|topsoil|clay|silt|sand|gravel|cobble(?:s)?|boulder(?:s)?|peat|chalk|rock|sandstone|limestone|granite|shale|mudstone|siltstone|basalt)\b/g;
    let m;
    while ((m = re.exec(t)) !== null) {
      const raw = m[1].replace(/\s+/g, " ");
      if (raw === "top soil") negated.add("topsoil");
      else if (raw === "fill" || raw === "made ground") negated.add("made ground");
      else if (raw === "cobble" || raw === "cobbles") negated.add("cobbles");
      else if (raw === "boulder" || raw === "boulders") negated.add("boulders");
      else negated.add(raw);
    }
    return negated;
  }

  function filterNegatedMaterials(materials, negated) {
    if (!negated || !negated.size) return materials;
    return materials.filter((m) => !negated.has(m));
  }

  function detectStrength(text) {
    const t = text.toLowerCase();
    const range = t.match(/\b(very\s+soft|soft|firm|stiff|very\s+stiff|hard)\s+to\s+(very\s+soft|soft|firm|stiff|very\s+stiff|hard)\b/);
    if (range) return range[1] + " to " + range[2];
    if (/\bvery\s+soft\b/.test(t)) return "very soft";
    if (/\bvery\s+stiff\b/.test(t)) return "very stiff";
    if (/\bhard\b/.test(t)) return "hard";
    if (/\bstiff\b/.test(t)) return "stiff";
    if (/\bfirm\b/.test(t)) return "firm";
    if (/\bsoft\b/.test(t)) return "soft";
    return null;
  }

  function detectMoisture(text) {
    const t = text.toLowerCase();
    if (/\bvery\s+wet\b|\bsaturated\b/.test(t)) return "wet";
    if (/\bwet\b/.test(t)) return "wet";
    if (/\bslightly\s+moist\b/.test(t)) return "slightly moist";
    if (/\bdamp\b/.test(t)) return "moist";
    if (/\bmoist\b/.test(t)) return "moist";
    if (/\bdry\b/.test(t)) return "dry";
    return null;
  }

  function detectDensity(text) {
    const t = text.toLowerCase();
    const range = t.match(/\b(very\s+loose|loose|medium\s+dense|dense|very\s+dense)\s+to\s+(very\s+loose|loose|medium\s+dense|dense|very\s+dense)\b/);
    if (range) return range[1] + " to " + range[2];
    if (/\bvery\s+loose\b/.test(t)) return "very loose";
    if (/\bvery\s+dense\b/.test(t)) return "very dense";
    if (/\bmedium\s+dense\b/.test(t)) return "medium dense";
    if (/\bdense\b/.test(t)) return "dense";
    if (/\bloose\b/.test(t)) return "loose";
    return null;
  }

  function detectPlasticity(text) {
    const t = text.toLowerCase();
    if (/\bhigh\s+plasticity\b/.test(t)) return "high";
    if (/\bintermediate\s+plasticity\b|\bmedium\s+plasticity\b/.test(t)) return "medium";
    if (/\blow\s+plasticity\b/.test(t)) return "low";
    return null;
  }

  function detectQualifiers(text) {
    const t = text.toLowerCase();
    const q = { strength: detectStrength(t), moisture: detectMoisture(t), odor: null, contamination: false, uncertainty: false };

    if (/\bsmell(?:s|ing)?\b|\bodou?r\b|\bsulphurous\b|\bh2s\b/.test(t)) q.odor = "noted";
    if (/\bhydrocarbon\b|\boil\b|\bdiesel\b|\btarry\b|\basbestos\b|\bcontaminat(?:ed|ion)\b/.test(t)) q.contamination = true;

    if (/\bmaybe\b|\bperhaps\b|\bi\s+think\b|\bnot\s+sure\b|\bpossibly\b|\bcould\s+be\b|\blikely\b/.test(t)) q.uncertainty = true;

    return q;
  }

  const reTypeTest = /\b(spt|standard\s+penetration|vane|cpt|cone\s+penetration|dcp|pressuremeter|plate\s+load|in[- ]?situ|permeability)\b/;
  const reTypeSample = /\b(sample|sampling|u\d+|u\s*100|u\s*38|undisturbed|disturbed|bulk|bag|jar|block|split\s*spoon)\b/;
  const reTypeWater = /\b(water\s+level|water\s+strike|standing\s+water|seepage|seep|inflow|groundwater|wl)\b/;
  const reTypeStrata = /\b(clay|silt|sand|gravel|cobble|boulder|topsoil|made\s+ground|fill|peat|rock|chalk)\b/;
  const reHorizonRef = /\b(horizon|layer)\s*(?:#|id)?\s*(?:h?\s*\d+|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|one|two|three|four|five|six|seven|eight|nine|ten)\b/;
  const reHorizonRefOrdinal = /\b(first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|one|two|three|four|five|six|seven|eight|nine|ten)\s+(?:layer|horizon)\b/;
  const reHorizonId = /\bh\s*\d+\b/;

  function detectTypeSignals(text) {
    const t = (text || "").toLowerCase();
    const signals = {
      test: reTypeTest.test(t),
      sample: reTypeSample.test(t),
      water: reTypeWater.test(t),
      strata: reTypeStrata.test(t) || reHorizonRef.test(t) || reHorizonRefOrdinal.test(t) || reHorizonId.test(t)
    };
    const primaryCount = [signals.test, signals.sample, signals.water].filter(Boolean).length;
    const totalCount = [signals.test, signals.sample, signals.water, signals.strata].filter(Boolean).length;
    return { ...signals, primaryCount, totalCount };
  }

  function detectEntryType(text, override, options = {}) {
    if (override && override !== "auto") return override;
    const signals = detectTypeSignals(text);
    const allowMixed = options.allowMixed !== false;
    const hasMultipleDepths = countDepthMarkers(text) >= 2;
    const mixedLikely = allowMixed && (signals.primaryCount > 1 || (signals.primaryCount === 1 && signals.strata && hasMultipleDepths));
    if (mixedLikely) return "mixed";
    if (signals.test) return "test";
    if (signals.sample) return "sample";
    if (signals.water) return "water";
    if (signals.strata) return "strata";
    return "note";
  }

  function insertImplicitStrataSplits(text) {
    const t = text || "";
    const startToken = "(?:horizon|layer|h\\s*\\d+|clay|silt|sand|gravel|cobble|boulder|topsoil|made\\s+ground|fill|peat|rock|chalk)";
    const toRe = new RegExp("\\b((?:to|down\\s+to)\\s+\\d+(?:\\.\\d+)?\\s*(?:m|metres|meters)?)\\b[\\s,;]+(?=" + startToken + ")", "gi");
    const rangeRe = new RegExp("\\b(\\d+(?:\\.\\d+)?\\s*(?:m|metres|meters)?\\s*-\\s*\\d+(?:\\.\\d+)?\\s*(?:m|metres|meters)?)\\b[\\s,;]+(?=" + startToken + ")", "gi");
    return t.replace(toRe, "$1||").replace(rangeRe, "$1||");
  }

  function splitStrataSegments(raw) {
    let t = raw || "";
    const markers = [
      /\bunderlain\s+by\b/gi,
      /\boverlain\s+by\b/gi,
      /\boverlies\b/gi,
      /\boverlying\b/gi,
      /\bunderlying\b/gi,
      /\bbeneath\b/gi,
      /\bbelow\b/gi,
      /\bfollowed\s+by\b/gi,
      /\bthen\b/gi,
      /\bunderlain\b/gi
    ];
    for (const re of markers) t = t.replace(re, "||");
    t = insertImplicitStrataSplits(t);
    t = t.replace(/\.(?=\s+[a-zA-Z])/g, "||");
    return t.split("||").map(s => s.trim()).filter(Boolean);
  }

  function parseStrataLayersFromText(raw) {
    const segments = splitStrataSegments(raw);
    const layers = [];
    const baseIndex = state.log?.strata?.length || 0;
    let lastTo = getLastStratumTo(state.log);
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const depth = extractDepthsSingle(segment);
        const negated = detectNegatedMaterials(segment);
        const materials = filterNegatedMaterials(guessMaterial(segment), negated);
        const qualifiers = detectQualifiers(segment);
        const density = detectDensity(segment);
        const color = extractColor(segment);
        const structure = extractStructure(segment);
        const plasticity = detectPlasticity(segment);
      const bs5930 = buildBS5930({ raw: segment, materials, qualifiers, density, color, structure, plasticity });
      let from = depth.from;
      let to = depth.to;
      let inferred = false;
      const hasDepth = from != null || to != null;
      const hasNext = i < segments.length - 1;
      if (!hasDepth && hasNext && bs5930.primary) {
        const existing = findExistingStratumByPrimary(bs5930.primary, state.log);
        if (existing && isFiniteNumber(existing.to)) {
          lastTo = existing.to;
          continue;
        }
      }
      if (from == null && to != null && lastTo != null) {
        from = lastTo;
        inferred = true;
      }
      if (from != null && to != null && to < from) {
        const tmp = from;
        from = to;
        to = tmp;
        inferred = true;
      }
      if (to != null) lastTo = to;
      layers.push({
        id: "H" + (baseIndex + layers.length + 1),
        explicit_id: false,
        from,
        to,
        material: bs5930.primary || materials[0]?.toUpperCase() || "UNKNOWN",
        descriptors: bs5930.secondary || [],
        bs5930,
        raw: segment,
        confidence: 1,
        inferred_from_context: inferred
      });
    }
    return layers;
  }

  function extractOrdinalHorizonId(text) {
    const t = (text || "").toLowerCase();
    const ordinals = {
      first: 1, second: 2, third: 3, fourth: 4, fifth: 5,
      sixth: 6, seventh: 7, eighth: 8, ninth: 9, tenth: 10
    };
    const numbers = {
      one: 1, two: 2, three: 3, four: 4, five: 5,
      six: 6, seven: 7, eight: 8, nine: 9, ten: 10
    };
    const word = "(?:first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|one|two|three|four|five|six|seven|eight|nine|ten)";
    let match = t.match(new RegExp("\\b(?:layer|horizon)\\s+(" + word + ")\\b"));
    if (!match) match = t.match(new RegExp("\\b(" + word + ")\\s+(?:layer|horizon)\\b"));
    if (!match) return null;
    const key = match[1];
    const value = ordinals[key] || numbers[key] || null;
    return value ? ("H" + value) : null;
  }

  function extractHorizonId(text) {
    const t = (text || "").toLowerCase();
    const match = t.match(/\b(horizon|layer)\s*(?:#|id)?\s*(h?\s*\d+)\b/);
    if (!match) {
      const ordinal = extractOrdinalHorizonId(t);
      if (ordinal) return ordinal;
      const direct = t.match(/\bh\s*\d+\b/);
      if (!direct) return null;
      const rawDirect = direct[0].replace(/\s+/g, "").toUpperCase();
      return rawDirect.startsWith("H") ? rawDirect : ("H" + rawDirect);
    }
    const raw = match[2].replace(/\s+/g, "").toUpperCase();
    return raw.startsWith("H") ? raw : ("H" + raw);
  }

  function extractColor(text) {
    const t = text.toLowerCase();
    const combo = t.match(/\b(dark|light|pale|medium)\s+(brown|grey|gray|red|yellow|green|blue|black)\b/);
    if (combo) return combo[1] + " " + (combo[2] === "gray" ? "grey" : combo[2]);
    const multi = t.match(/\b(reddish\s+brown|yellowish\s+brown|greyish\s+brown)\b/);
    if (multi) return multi[1];
    const single = t.match(/\b(brown|grey|gray|red|yellow|green|blue|black|white|pink|cream|beige|buff|orange)\b/);
    if (single) return single[1] === "gray" ? "grey" : single[1];
    return null;
  }

  function normalizeColorToken(color) {
    if (!color) return null;
    const cleaned = color.trim().toLowerCase().replace(/\s+/g, " ");
    return cleaned.replace("gray", "grey");
  }

  function extractColorChange(text) {
    const t = (text || "").toLowerCase();
    const colorPattern = "(?:dark|light|pale|medium)\\s+(?:brown|grey|gray|red|yellow|green|blue|black)|(?:reddish\\s+brown|yellowish\\s+brown|greyish\\s+brown)|(?:brown|grey|gray|red|yellow|green|blue|black|white|pink|cream|beige|buff|orange)";
    const toMatch = t.match(new RegExp("\\bto\\s+(" + colorPattern + ")\\b"));
    if (toMatch) return normalizeColorToken(toMatch[1]);
    const insteadMatch = t.match(new RegExp("\\b(" + colorPattern + ")\\b\\s+(?:instead\\s+of|rather\\s+than)\\b"));
    if (insteadMatch) return normalizeColorToken(insteadMatch[1]);
    return extractColor(text);
  }

  function extractStructure(text) {
    const t = text.toLowerCase();
    const structures = [];
    const rules = [
      ["fissured", /\bfissured\b/],
      ["laminated", /\blaminated\b/],
      ["bedded", /\bbedded\b|\bbanded\b/],
      ["layered", /\blayered\b/],
      ["massive", /\bmassive\b/],
      ["mottled", /\bmottled\b|\bvariegated\b/],
      ["rootlets", /\brootlets?\b/],
      ["shells", /\bshells?\b/],
      ["fractured", /\bfractured\b/],
      ["slickensided", /\bslickensided\b/]
    ];
    for (const [name, re] of rules) if (re.test(t)) structures.push(name);
    return structures;
  }

  function extractOtherFeatures(text) {
    const t = text.toLowerCase();
    const features = [];
    const rules = [
      ["brick fragments", /\bbrick\b/],
      ["concrete fragments", /\bconcrete\b/],
      ["ash", /\bash\b/],
      ["slag", /\bslag\b/],
      ["glass", /\bglass\b/],
      ["coal", /\bcoal\b/],
      ["roots", /\broots?\b/]
    ];
    for (const [name, re] of rules) if (re.test(t)) features.push(name);
    return features;
  }

  function selectPrimaryMaterial(materials, text) {
    const t = text.toLowerCase();
    const negated = detectNegatedMaterials(text);
    const rockMatch = t.match(/\b(sandstone|limestone|mudstone|siltstone|shale|granite|basalt|chalk)\b/);
    if (rockMatch) {
      const rockKey = rockMatch[1].toLowerCase();
      if (!negated.has("rock") && !negated.has(rockKey)) return rockMatch[1].toUpperCase();
    }
    if (!negated.has("made ground") && (/\bmade\s+ground\b|\bfill\b/.test(t))) return "MADE GROUND";
    if (!negated.has("topsoil") && (/\btop\s*soil\b|\btopsoil\b/.test(t))) return "TOPSOIL";
    if (!negated.has("peat") && (/\bpeat\b/.test(t))) return "PEAT";
    if (!negated.has("chalk") && (/\bchalk\b/.test(t))) return "CHALK";
    const order = ["clay", "silt", "sand", "gravel", "cobbles", "boulders", "rock"];
    for (const key of order) if (materials.includes(key) && !negated.has(key)) return key.toUpperCase();
    return null;
  }

  function extractSecondaryDescriptors(text, primary, materials) {
    const t = text.toLowerCase();
    const secondary = new Set();
    const adjRules = [
      ["sandy", /\bsandy\b|\bwith\s+sand\b/],
      ["gravelly", /\bgravelly\b|\bwith\s+gravel\b/],
      ["silty", /\bsilty\b|\bwith\s+silt\b/],
      ["clayey", /\bclayey\b|\bwith\s+clay\b/],
      ["cobbly", /\bcobbly\b|\bwith\s+cobbles\b/],
      ["bouldery", /\bbouldery\b|\bwith\s+boulders\b/],
      ["chalky", /\bchalky\b|\bwith\s+chalk\b/],
      ["peaty", /\bpeaty\b|\bwith\s+peat\b/],
      ["organic", /\borganic\b/]
    ];
    for (const [name, re] of adjRules) if (re.test(t)) secondary.add(name);

    const materialAdjMap = {
      sand: "sandy",
      gravel: "gravelly",
      silt: "silty",
      clay: "clayey",
      cobbles: "cobbly",
      boulders: "bouldery",
      chalk: "chalky",
      peat: "peaty"
    };
    for (const mat of materials) {
      if (materialAdjMap[mat]) secondary.add(materialAdjMap[mat]);
    }

    const primaryBaseMap = {
      "MADE GROUND": "made ground",
      "TOPSOIL": "topsoil",
      "CLAY": "clay",
      "SILT": "silt",
      "SAND": "sand",
      "GRAVEL": "gravel",
      "COBBLES": "cobbles",
      "BOULDERS": "boulders",
      "PEAT": "peat",
      "CHALK": "chalk",
      "ROCK": "rock"
    };
    const primaryBase = primary ? (primaryBaseMap[primary] || primary.toLowerCase()) : null;
    const adjBaseMap = {
      sandy: "sand",
      gravelly: "gravel",
      silty: "silt",
      clayey: "clay",
      cobbly: "cobbles",
      bouldery: "boulders",
      chalky: "chalk",
      peaty: "peat"
    };
    if (primaryBase) {
      for (const adj of Array.from(secondary)) {
        if (adjBaseMap[adj] === primaryBase) secondary.delete(adj);
      }
    }
    return Array.from(secondary);
  }

  function extractMaterialChange(text) {
    const t = (text || "").toLowerCase();
    const materialPattern = "(?:made\\s+ground|top\\s*soil|topsoil|clay|silt|sand|gravel|cobble(?:s)?|boulder(?:s)?|peat|chalk|rock|sandstone|limestone|granite|shale|mudstone|siltstone|basalt)";
    const toMatch = t.match(new RegExp("\\bto\\s+(" + materialPattern + ")\\b"));
    if (toMatch) {
      const raw = toMatch[1];
      const materials = guessMaterial(raw);
      return selectPrimaryMaterial(materials, raw) || raw.toUpperCase();
    }
    const insteadMatch = t.match(new RegExp("\\b(" + materialPattern + ")\\b\\s+(?:instead\\s+of|rather\\s+than)\\b"));
    if (insteadMatch) {
      const raw = insteadMatch[1];
      const materials = guessMaterial(raw);
      return selectPrimaryMaterial(materials, raw) || raw.toUpperCase();
    }
    return null;
  }

  function extractChangeValue(text, pattern) {
    const t = (text || "").toLowerCase();
    const fromMatch = t.match(new RegExp("\\bfrom\\s+(" + pattern + ")\\s+to\\s+(" + pattern + ")\\b"));
    if (fromMatch) return fromMatch[2].trim().replace(/\s+/g, " ");
    const insteadMatch = t.match(new RegExp("\\b(" + pattern + ")\\b\\s+(?:instead\\s+of|rather\\s+than)\\b"));
    if (insteadMatch) return insteadMatch[1].trim().replace(/\s+/g, " ");
    return null;
  }

  function extractStrengthChange(text) {
    const pattern = "(?:very\\s+soft|soft|firm|stiff|very\\s+stiff|hard)";
    const value = extractChangeValue(text, pattern);
    return value || detectStrength(text);
  }

  function extractDensityChange(text) {
    const pattern = "(?:very\\s+loose|loose|medium\\s+dense|dense|very\\s+dense)";
    const value = extractChangeValue(text, pattern);
    return value || detectDensity(text);
  }

  function normalizeMoistureToken(value) {
    if (!value) return null;
    if (/saturated/.test(value) || /very\s+wet/.test(value) || /\bwet\b/.test(value)) return "wet";
    if (/slightly\s+moist/.test(value)) return "slightly moist";
    if (/\bdamp\b/.test(value)) return "moist";
    if (/\bmoist\b/.test(value)) return "moist";
    if (/\bdry\b/.test(value)) return "dry";
    return null;
  }

  function extractMoistureChange(text) {
    const pattern = "(?:very\\s+wet|wet|saturated|slightly\\s+moist|damp|moist|dry)";
    const value = extractChangeValue(text, pattern);
    return normalizeMoistureToken(value) || detectMoisture(text);
  }

  function extractPlasticityChange(text) {
    const pattern = "(?:high\\s+plasticity|medium\\s+plasticity|intermediate\\s+plasticity|low\\s+plasticity)";
    const value = extractChangeValue(text, pattern);
    if (value) {
      if (value.startsWith("high")) return "high";
      if (value.startsWith("medium") || value.startsWith("intermediate")) return "medium";
      if (value.startsWith("low")) return "low";
    }
    return detectPlasticity(text);
  }

  function extractStratumPatch(raw) {
    const text = raw || "";
    const depth = extractDepthsSingle(text);
    const negated = detectNegatedMaterials(text);
    const materials = filterNegatedMaterials(guessMaterial(text), negated);
    const hasMaterial = materials.some((m) => m !== "unknown");
    const explicitPrimary = extractMaterialChange(text);
    const primary = explicitPrimary || (hasMaterial ? selectPrimaryMaterial(materials, text) : null);
    const materialMentioned = Boolean(explicitPrimary) || hasMaterial;
    const secondary = extractSecondaryDescriptors(text, primary, materials);
    const secondaryMentioned = secondary.length > 0;
    const color = extractColorChange(text);
    const moisture = extractMoistureChange(text);
    const consistency = extractStrengthChange(text);
    const density = extractDensityChange(text);
    const plasticity = extractPlasticityChange(text);
    const structure = extractStructure(text);
    const other = extractOtherFeatures(text);
    const from = isFiniteNumber(depth.from) ? depth.from : null;
    const to = isFiniteNumber(depth.to) ? depth.to : null;
    const hasAny = materialMentioned || secondaryMentioned || Boolean(color || moisture || consistency || density || plasticity)
      || (structure && structure.length) || (other && other.length)
      || isFiniteNumber(from) || isFiniteNumber(to);
    return {
      hasAny,
      materialMentioned,
      secondaryMentioned,
      primary,
      secondary,
      color,
      moisture,
      consistency,
      density,
      plasticity,
      structure,
      other,
      from,
      to
    };
  }

  function normalizeMoisture(moisture) {
    if (!moisture) return null;
    if (moisture === "wet/saturated") return "wet";
    return moisture;
  }

  function buildBS5930(parsed) {
    const rawText = parsed.raw || "";
    const materials = parsed.materials && parsed.materials.length ? parsed.materials : guessMaterial(rawText);
    const primary = selectPrimaryMaterial(materials, rawText);
    const secondary = extractSecondaryDescriptors(rawText, primary, materials);
    const moisture = normalizeMoisture(parsed.qualifiers?.moisture || detectMoisture(rawText));
    const isCohesive = primary === "CLAY" || primary === "SILT";
    const isGranular = primary === "SAND" || primary === "GRAVEL" || primary === "COBBLES" || primary === "BOULDERS";
    const consistency = isCohesive ? (parsed.qualifiers?.strength || detectStrength(rawText)) : null;
    const density = isGranular ? (parsed.density || detectDensity(rawText)) : null;
    const color = parsed.color || extractColor(rawText);
    const structure = parsed.structure || extractStructure(rawText);
    const plasticity = parsed.plasticity || detectPlasticity(rawText);
    const other = parsed.other || extractOtherFeatures(rawText);

    const head = [];
    if (color) head.push(color);
    if (secondary.length) head.push(secondary.join(" "));
    if (primary) head.push(primary);
    const tail = [];
    if (consistency) tail.push(consistency);
    if (density) tail.push(density);
    if (moisture) tail.push(moisture);
    if (plasticity) tail.push(plasticity + " plasticity");
    if (structure.length) tail.push(structure.join(", "));
    if (other.length) tail.push(other.join(", "));

    let description = head.join(" ");
    if (tail.length) description = description ? (description + ", " + tail.join(", ")) : tail.join(", ");
    if (!description) description = "Unclassified";

    return {
      primary,
      secondary,
      color,
      moisture,
      consistency,
      density,
      plasticity,
      structure,
      other,
      description
    };
  }

  function normalizeMaterialKey(value) {
    return String(value || "").trim().toUpperCase().replace(/\s+/g, " ");
  }

  function findExistingStratumByPrimary(primary, log) {
    const key = normalizeMaterialKey(primary);
    if (!key) return null;
    const strata = log?.strata || [];
    const matches = strata.filter((layer) => {
      const mat = normalizeMaterialKey(layer?.bs5930?.primary || layer?.material);
      return mat && mat === key;
    });
    if (!matches.length) return null;
    matches.sort((a, b) => (a.from ?? a.to ?? Infinity) - (b.from ?? b.to ?? Infinity));
    return matches[0];
  }

  function formatBS5930Description(bs) {
    if (!bs) return "Unclassified";
    const head = [];
    if (bs.color) head.push(bs.color);
    if (Array.isArray(bs.secondary) && bs.secondary.length) head.push(bs.secondary.join(" "));
    if (bs.primary) head.push(bs.primary);
    const tail = [];
    if (bs.consistency) tail.push(bs.consistency);
    if (bs.density) tail.push(bs.density);
    if (bs.moisture) tail.push(bs.moisture);
    if (bs.plasticity) tail.push(bs.plasticity + " plasticity");
    if (Array.isArray(bs.structure) && bs.structure.length) tail.push(bs.structure.join(", "));
    if (Array.isArray(bs.other) && bs.other.length) tail.push(bs.other.join(", "));
    let description = head.join(" ");
    if (tail.length) description = description ? (description + ", " + tail.join(", ")) : tail.join(", ");
    return description || "Unclassified";
  }

  function getLastStratumTo(log) {
    const strata = log?.strata || [];
    for (let i = strata.length - 1; i >= 0; i--) {
      const val = strata[i].to;
      if (typeof val === "number" && isFinite(val)) return val;
    }
    return null;
  }

  function inferLayerBounds(layer, log) {
    let from = layer.from;
    let to = layer.to;
    let inferred = false;
    const lastTo = getLastStratumTo(log);
    if (from == null && to != null && lastTo != null) {
      from = lastTo;
      inferred = true;
    }
    if (from != null && to != null && to < from) {
      const tmp = from;
      from = to;
      to = tmp;
      inferred = true;
    }
    return { from, to, inferred };
  }

  function getLayerStart(layer) {
    if (isFiniteNumber(layer?.from)) return layer.from;
    if (isFiniteNumber(layer?.to)) return layer.to;
    return null;
  }

  function getLayerEnd(layer) {
    if (isFiniteNumber(layer?.to)) return layer.to;
    if (isFiniteNumber(layer?.from)) return layer.from;
    return null;
  }

  function clampLayerBounds(layer) {
    if (!layer) return;
    if (isFiniteNumber(layer.from) && isFiniteNumber(layer.to) && layer.to < layer.from) {
      layer.to = layer.from;
    }
  }

  function reconcileStrataBounds(strata, changedLayer) {
    if (!changedLayer) return;
    const hasBounds = isFiniteNumber(changedLayer.from) || isFiniteNumber(changedLayer.to);
    if (!hasBounds) return;
    const ordered = strata.filter((l) => l && (isFiniteNumber(l.from) || isFiniteNumber(l.to)));
    if (!ordered.length) return;
    ordered.sort((a, b) => (getLayerStart(a) ?? Infinity) - (getLayerStart(b) ?? Infinity));
    const idx = ordered.indexOf(changedLayer);
    if (idx === -1) return;
    const prev = idx > 0 ? ordered[idx - 1] : null;
    const next = idx < ordered.length - 1 ? ordered[idx + 1] : null;
    const changedFrom = isFiniteNumber(changedLayer.from) ? changedLayer.from : null;
    const changedTo = isFiniteNumber(changedLayer.to) ? changedLayer.to : null;

    if (prev && changedFrom != null) {
      const prevTo = isFiniteNumber(prev.to) ? prev.to : null;
      if (prevTo != null && prevTo > changedFrom) {
        prev.to = changedFrom;
        clampLayerBounds(prev);
      }
    }
    if (next && changedTo != null) {
      const nextFrom = isFiniteNumber(next.from) ? next.from : null;
      if (nextFrom != null && nextFrom < changedTo) {
        next.from = changedTo;
        clampLayerBounds(next);
      }
    }

    for (let i = Math.max(0, idx - 1); i < ordered.length - 1; i++) {
      const a = ordered[i];
      const b = ordered[i + 1];
      if (b === changedLayer) continue;
      const aEnd = getLayerEnd(a);
      if (aEnd == null) continue;
      const bStart = getLayerStart(b);
      if (bStart != null && aEnd > bStart) {
        b.from = aEnd;
        clampLayerBounds(b);
      }
    }
  }

  function buildLayerFromParsed(parsed) {
    const depth = parsed.depth || { from: null, to: null };
    const bs5930 = parsed.bs5930 || buildBS5930(parsed);
    const materialFallback = parsed.materials && parsed.materials.length ? parsed.materials[0].toUpperCase() : null;
    const layer = {
      from: depth.from,
      to: depth.to,
      material: bs5930.primary || materialFallback || "UNKNOWN",
      descriptors: bs5930.secondary || [],
      bs5930,
      raw: parsed.raw,
      confidence: 1,
      inferred_from_context: false
    };
    const inferred = inferLayerBounds(layer, state.log);
    layer.from = inferred.from;
    layer.to = inferred.to;
    layer.inferred_from_context = inferred.inferred;
    if (parsed.depth) {
      parsed.depth.from = inferred.from;
      parsed.depth.to = inferred.to;
    }
    return layer;
  }

  function detectSampleType(text) {
    const t = text.toLowerCase();
    const uMatch = t.match(/\bu\s*([0-9]{2,3})\b/);
    if (uMatch) return "U" + uMatch[1];
    if (/\bundisturbed\b/.test(t)) return "undisturbed";
    if (/\bdisturbed\b/.test(t)) return "disturbed";
    if (/\bbulk\b/.test(t)) return "bulk";
    if (/\bbag\b/.test(t)) return "bag";
    if (/\bjar\b/.test(t)) return "jar";
    if (/\bblock\b/.test(t)) return "block";
    if (/\bsplit\s*spoon\b/.test(t)) return "split spoon";
    if (/\bgrab\b/.test(t)) return "grab";
    return null;
  }

  function countDepthMarkers(text) {
    return extractDepthMarkersAll(text).length;
  }

  function extractDepthMarkersAll(text) {
    const t = preprocessTranscript(text || "");
    const markers = [];
    const reList = /\b(\d+(?:\.\d+)?\s*(?:m|metres|meters)?(?:\s*,\s*\d+(?:\.\d+)?\s*(?:m|metres|meters)?)+(?:\s*(?:and|&)\s*\d+(?:\.\d+)?\s*(?:m|metres|meters)?)?)\b/gi;
    let listMatch;
    while ((listMatch = reList.exec(t)) !== null) {
      if (!/(?:m|metres|meters)/.test(listMatch[0])) continue;
      const listText = listMatch[1] || "";
      const numRe = /\d+(?:\.\d+)?/g;
      let numMatch;
      while ((numMatch = numRe.exec(listText)) !== null) {
        markers.push({ depth: parseFloat(numMatch[0]), index: listMatch.index + numMatch.index });
      }
    }
    const reM = /\b(\d+(?:\.\d+)?)\s*(?:m|metres|meters)\b/gi;
    let m;
    while ((m = reM.exec(t)) !== null) {
      markers.push({ depth: parseFloat(m[1]), index: m.index });
    }
    const reAt = /\b(?:at|depth|@|around|approx(?:imately)?|about)\s+(\d+(?:\.\d+)?)(?!\.\d)(?!\s*(?:m|metres|meters))\b/gi;
    while ((m = reAt.exec(t)) !== null) {
      markers.push({ depth: parseFloat(m[1]), index: m.index });
    }
    markers.sort((a, b) => a.index - b.index);
    const depths = [];
    for (const marker of markers) {
      if (!isFiniteNumber(marker.depth)) continue;
      const last = depths[depths.length - 1];
      if (last == null || Math.abs(marker.depth - last) > 1e-6) depths.push(marker.depth);
    }
    return depths;
  }

  function allItemsArePointDepth(items) {
    return items.every((item) => item && item.from == null && item.to == null);
  }

  function splitMultiItems(raw, allowAndSplit = false, includeComma = false) {
    let t = raw || "";
    t = t.replace(/\bbetween\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\s+and\s+(\d+(?:\.\d+)?)\s*(?:m|metres|meters)?\b/gi,
      (m) => m.replace(/\sand\s/i, " & ")
    );
    const parts = [];
    const tokens = [];
    if (includeComma) tokens.push(",\\s*");
    tokens.push("\\.\\s+", ";\\s+", "\\bthen\\b", "\\bfollowed by\\b", "\\bafter that\\b", "\\bplus\\b", "\\balso\\b");
    if (allowAndSplit) tokens.push("\\band\\b");
    const re = new RegExp(tokens.join("|"), "i");
    const split = t.split(re).map(s => (s || "").trim()).filter(Boolean);
    for (const seg of split) {
      const restored = seg.replace(/\s*&\s*/g, " and ").trim();
      if (restored) parts.push(restored);
    }
    return parts.length ? parts : [raw];
  }

  function stripJoiners(text) {
    return (text || "")
      .replace(/^(?:and|also|plus|then|followed by|after that|with|including|along with)\b\s*/i, "")
      .replace(/\s+\b(?:and|also|plus|then|followed by|after that|with|including|along with)\b$/i, "")
      .trim();
  }

  function collectPrimaryMatches(text) {
    const matches = [];
    const rules = [
      ["sample", reTypeSample],
      ["test", reTypeTest],
      ["water", reTypeWater]
    ];
    for (const [type, baseRe] of rules) {
      const re = new RegExp(baseRe.source, "ig");
      let m;
      while ((m = re.exec(text)) !== null) {
        matches.push({ index: m.index, type, match: m[0] });
      }
    }
    matches.sort((a, b) => a.index - b.index);
    return matches;
  }

  function splitByPrimaryKeywords(segment) {
    const text = segment || "";
    const matches = collectPrimaryMatches(text);
    if (!matches.length) return [text];
    if (matches.length === 1) {
      const idx = matches[0].index;
      const head = text.slice(0, idx).trim();
      const tail = text.slice(idx).trim();
      if (head && reTypeStrata.test(head)) return [head, tail];
      return [text];
    }
    const parts = [];
    let includeHead = false;
    const first = matches[0];
    const head = text.slice(0, first.index).trim();
    if (head) {
      if (reTypeStrata.test(head)) parts.push(head);
      else includeHead = true;
    }
    for (let i = 0; i < matches.length; i++) {
      const start = matches[i].index;
      const end = (i + 1 < matches.length) ? matches[i + 1].index : text.length;
      const sliceStart = (i === 0 && includeHead) ? 0 : start;
      const part = text.slice(sliceStart, end).trim();
      if (part) parts.push(part);
    }
    return parts.length ? parts : [text];
  }

  function isMeaningfulSegment(segment) {
    const s = (segment || "").trim();
    if (!s) return false;
    const signals = detectTypeSignals(s);
    if (signals.totalCount > 0) return true;
    const words = s.split(/\s+/).filter(Boolean);
    return words.length >= 2 && s.length >= 6;
  }

  function parseSample(text) {
    const raw = text || "";
    const t = preprocessTranscript(raw);
    const depthRange = extractDepthsSingle(raw);
    const marker = extractDepthMarker(raw);
    const type = detectSampleType(t);
    const idMatch = t.match(/\b(?:sample|s)\s*#?\s*(\d+)\b/);
    const sample = {
      depth: null,
      from: null,
      to: null,
      type,
      id: idMatch ? ("S" + idMatch[1]) : null,
      raw
    };
    if (depthRange.from !== null || depthRange.to !== null) {
      sample.from = depthRange.from;
      sample.to = depthRange.to;
      sample.depth = (depthRange.from != null && depthRange.to != null)
        ? (depthRange.from + depthRange.to) / 2
        : (depthRange.to ?? depthRange.from);
      sample.depth_basis = depthRange.basis;
    } else if (marker.depth != null) {
      sample.depth = marker.depth;
      sample.depth_basis = marker.basis;
    }
    return sample;
  }

  function parseSamplesFromText(raw) {
    const baseType = detectSampleType(raw || "");
    const allowAndSplit = countDepthMarkers(raw) >= 2;
    const segments = splitMultiItems(raw, allowAndSplit, allowAndSplit);
    const samples = [];
    let pending = "";
    for (const seg of segments) {
      const segment = pending ? (pending + " " + seg) : seg;
      const s = parseSample(segment);
      if (!s.type && baseType) s.type = baseType;
      if (s.depth == null && s.from == null && s.to == null) {
        pending = segment;
        if (segments.length > 1) continue;
      } else {
        pending = "";
      }
      samples.push(s);
    }
    if (!samples.length) {
      const fallback = parseSample(raw);
      if (!fallback.type && baseType) fallback.type = baseType;
      samples.push(fallback);
    }
    const depthMarkers = extractDepthMarkersAll(raw);
    if (depthMarkers.length > samples.length && allItemsArePointDepth(samples)) {
      return depthMarkers.map((depth) => {
        const s = parseSample(`sample at ${depth}m`);
        if (!s.type && baseType) s.type = baseType;
        s.raw = raw;
        return s;
      });
    }
    return samples;
  }

  function parseTimeMinutes(text) {
    const t = text.toLowerCase();
    const m = t.match(/\b(\d+(?:\.\d+)?)\s*(min|mins|minutes|hr|hrs|hours|h)\b/);
    if (!m) return null;
    const val = parseFloat(m[1]);
    const unit = m[2];
    return unit.startsWith("h") ? Math.round(val * 60) : Math.round(val);
  }

  function parseWater(text) {
    const raw = text || "";
    const t = preprocessTranscript(raw);
    const depthRange = extractDepthsSingle(raw);
    const marker = extractDepthMarker(raw);
    const water = {
      depth: null,
      from: null,
      to: null,
      condition: null,
      remark: raw || null,
      time_minutes: parseTimeMinutes(t),
      raw
    };
    if (/\bno\s+water\b|\bdry\b/.test(t)) water.condition = "dry";
    if (/\bwater\s+strike\b|\bstrike\b/.test(t)) water.condition = "strike";
    if (/\bstanding\s+water\b/.test(t)) water.condition = "standing";
    if (/\bseepage\b|\bseep\b/.test(t)) water.condition = "seepage";
    if (/\binflow\b/.test(t)) water.condition = "inflow";

    if (depthRange.from !== null || depthRange.to !== null) {
      water.from = depthRange.from;
      water.to = depthRange.to;
      water.depth = depthRange.to ?? depthRange.from;
    } else if (marker.depth != null) {
      water.depth = marker.depth;
    }
    return water;
  }

  function parseWatersFromText(raw) {
    const base = parseWater(raw);
    const allowAndSplit = countDepthMarkers(raw) >= 2;
    const segments = splitMultiItems(raw, allowAndSplit, allowAndSplit);
    const waters = [];
    let pending = "";
    for (const seg of segments) {
      const segment = pending ? (pending + " " + seg) : seg;
      const w = parseWater(segment);
      if (!w.condition && base.condition) w.condition = base.condition;
      if (w.depth == null && w.from == null && w.to == null && w.condition !== "dry") {
        pending = segment;
        if (segments.length > 1) continue;
      } else {
        pending = "";
      }
      waters.push(w);
    }
    if (!waters.length) waters.push(base);
    const depthMarkers = extractDepthMarkersAll(raw);
    if (depthMarkers.length > waters.length && allItemsArePointDepth(waters)) {
      return depthMarkers.map((depth) => ({
        depth,
        from: null,
        to: null,
        condition: base.condition || null,
        remark: base.remark || raw || null,
        time_minutes: base.time_minutes ?? null,
        raw
      }));
    }
    return waters;
  }

  function detectTestType(text) {
    const t = text.toLowerCase();
    if (/\bspt\b|\bstandard\s+penetration\b/.test(t)) return "SPT";
    if (/\bvane\b/.test(t)) return "vane shear";
    if (/\bcpt\b|\bcone\s+penetration\b/.test(t)) return "CPT";
    if (/\bdcp\b/.test(t)) return "DCP";
    if (/\bpressuremeter\b/.test(t)) return "pressuremeter";
    if (/\bplate\s+load\b|\bplate\s+bearing\b/.test(t)) return "plate load";
    if (/\bpermeability\b/.test(t)) return "permeability";
    return null;
  }

  function parseTest(text) {
    const raw = text || "";
    const t = preprocessTranscript(raw);
    const depthRange = extractDepthsSingle(raw);
    const marker = extractDepthMarker(raw);
    let type = null;
    type = detectTestType(t);

    const resultParts = [];
    const nMatch = t.match(/\bn\s*=?\s*(\d+)\b/);
    if (nMatch) resultParts.push("N=" + nMatch[1]);
    const sptMatch = t.match(/\bspt\s*=?\s*(\d+)\b/);
    if (sptMatch && !nMatch) resultParts.push("N=" + sptMatch[1]);
    const blowsMatch = t.match(/\b(\d+)\s*blows\b/);
    if (blowsMatch && !nMatch) resultParts.push(blowsMatch[1] + " blows");
    const kpaMatch = t.match(/\b(\d+(?:\.\d+)?)\s*(kpa|kn\/m2|kn\s*\/\s*m2)\b/);
    if (kpaMatch) resultParts.push(kpaMatch[1] + " " + kpaMatch[2].replace(/\s+/g, ""));

    const test = {
      depth: null,
      from: null,
      to: null,
      type,
      result: resultParts.length ? resultParts.join(", ") : null,
      raw
    };
    if (depthRange.from !== null || depthRange.to !== null) {
      test.from = depthRange.from;
      test.to = depthRange.to;
      test.depth = depthRange.to ?? depthRange.from;
    } else if (marker.depth != null) {
      test.depth = marker.depth;
    }
    return test;
  }

  function parseTestsFromText(raw) {
    const baseType = detectTestType(raw || "");
    const allowAndSplit = countDepthMarkers(raw) >= 2;
    const segments = splitMultiItems(raw, allowAndSplit, allowAndSplit);
    const tests = [];
    let pending = "";
    for (const seg of segments) {
      const segment = pending ? (pending + " " + seg) : seg;
      const t = parseTest(segment);
      if (!t.type && baseType) t.type = baseType;
      if (t.depth == null && t.from == null && t.to == null) {
        pending = segment;
        if (segments.length > 1) continue;
      } else {
        pending = "";
      }
      tests.push(t);
    }
    if (!tests.length) {
      const fallback = parseTest(raw);
      if (!fallback.type && baseType) fallback.type = baseType;
      tests.push(fallback);
    }
    const depthMarkers = extractDepthMarkersAll(raw);
    if (depthMarkers.length > tests.length && allItemsArePointDepth(tests)) {
      const base = parseTest(raw);
      return depthMarkers.map((depth) => ({
        depth,
        from: null,
        to: null,
        type: base.type || baseType || null,
        result: base.result || null,
        raw
      }));
    }
    return tests;
  }

  function buildPrompts(parsed) {
    const prompts = [];
    if (!parsed) return prompts;
    const type = parsed.entry_type;
    if (type === "mixed") {
      const items = parsed.items || [];
      if (!items.length) return [{ level: "warn", text: "No items detected in mixed entry." }];
      for (const [idx, item] of items.entries()) {
        if (!item || item.entry_type === "mixed") continue;
        const sub = buildPrompts(item);
        for (const p of sub) {
          prompts.push({
            level: p.level,
            text: `Item ${idx + 1} (${item.entry_type}): ${p.text}`
          });
        }
      }
      return prompts;
    }
    if (type === "strata") {
      const layers = (parsed.layers && parsed.layers.length) ? parsed.layers : (parsed.layer ? [parsed.layer] : []);
      if (!layers.length) {
        prompts.push({ level: "warn", text: "No strata detected in this entry." });
      }
      layers.forEach((layer, idx) => {
        const bs = layer.bs5930 || {};
        const label = layer.id || layer.horizon_id || (idx + 1);
        const hasDepth = layer.from != null || layer.to != null;
        if (!hasDepth) prompts.push({ level: "warn", text: `Layer ${label}: depth interval not detected.` });
        if (!bs.primary) prompts.push({ level: "warn", text: `Layer ${label}: primary soil not detected for BS 5930 description.` });
        if (!bs.color) prompts.push({ level: "warn", text: `Layer ${label}: color not stated (e.g., dark brown, grey).` });
        if (!bs.moisture && bs.primary !== "ROCK") prompts.push({ level: "warn", text: `Layer ${label}: moisture not stated (dry / moist / wet).` });
        const cohesive = bs.primary === "CLAY" || bs.primary === "SILT";
        const granular = bs.primary === "SAND" || bs.primary === "GRAVEL" || bs.primary === "COBBLES" || bs.primary === "BOULDERS";
        if (cohesive && !bs.consistency) prompts.push({ level: "warn", text: `Layer ${label}: consistency not stated (soft/firm/stiff etc.).` });
        if (granular && !bs.density) prompts.push({ level: "warn", text: `Layer ${label}: density not stated (loose/medium dense/dense).` });
      });
    } else if (type === "sample") {
      const items = parsed.samples && parsed.samples.length ? parsed.samples : (parsed.sample ? [parsed.sample] : []);
      if (!items.length) prompts.push({ level: "warn", text: "No samples detected." });
      items.forEach((s, idx) => {
        if (!s.depth && s.from == null && s.to == null) prompts.push({ level: "warn", text: `Sample ${idx + 1}: depth not detected.` });
        if (!s.type) prompts.push({ level: "warn", text: `Sample ${idx + 1}: type not stated (U100, disturbed, bulk).` });
      });
    } else if (type === "water") {
      const items = parsed.waters && parsed.waters.length ? parsed.waters : (parsed.water ? [parsed.water] : []);
      if (!items.length) prompts.push({ level: "warn", text: "No water observations detected." });
      items.forEach((w, idx) => {
        if (!w.depth && w.from == null && w.to == null && w.condition !== "dry") {
          prompts.push({ level: "warn", text: `Water ${idx + 1}: depth not detected.` });
        }
      });
    } else if (type === "test") {
      const items = parsed.tests && parsed.tests.length ? parsed.tests : (parsed.test ? [parsed.test] : []);
      if (!items.length) prompts.push({ level: "warn", text: "No tests detected." });
      items.forEach((t, idx) => {
        if (!t.depth && t.from == null && t.to == null) prompts.push({ level: "warn", text: `Test ${idx + 1}: depth not detected.` });
        if (!t.type) prompts.push({ level: "warn", text: `Test ${idx + 1}: type not detected (SPT, vane, CPT).` });
        if (!t.result) prompts.push({ level: "warn", text: `Test ${idx + 1}: result not detected (e.g., N=15).` });
      });
    }
    return prompts;
  }

  function buildFollowupQuestions(prompts) {
    if (!Array.isArray(prompts)) return [];
    const questions = [];
    for (const p of prompts) {
      if (!p || p.level !== "warn") continue;
      const text = String(p.text || "").trim();
      if (!text) continue;
      let q = "";
      let m;
      if ((m = text.match(/^Layer\s+([^:]+): depth interval not detected/i))) {
        q = `What is the depth interval for layer ${m[1]}?`;
      } else if ((m = text.match(/^Layer\s+([^:]+): primary soil not detected/i))) {
        q = `What is the primary soil for layer ${m[1]}?`;
      } else if ((m = text.match(/^Layer\s+([^:]+): color not stated/i))) {
        q = `What is the color for layer ${m[1]}?`;
      } else if ((m = text.match(/^Layer\s+([^:]+): moisture not stated/i))) {
        q = `What is the moisture condition for layer ${m[1]} (dry/moist/wet)?`;
      } else if ((m = text.match(/^Layer\s+([^:]+): consistency not stated/i))) {
        q = `What is the consistency for layer ${m[1]} (soft/firm/stiff)?`;
      } else if ((m = text.match(/^Layer\s+([^:]+): density not stated/i))) {
        q = `What is the density for layer ${m[1]} (loose/medium dense/dense)?`;
      } else if ((m = text.match(/^Layer\s+(.+?) needs confirmation/i))) {
        q = `Can you confirm layer ${m[1]}?`;
      } else if (/No strata detected/i.test(text)) {
        q = "Can you describe the strata layers and depths?";
      } else if ((m = text.match(/^Sample\s+(\d+): depth not detected/i))) {
        q = `What is the depth for sample ${m[1]}?`;
      } else if ((m = text.match(/^Sample\s+(\d+): type not stated/i))) {
        q = `What is the type for sample ${m[1]} (U100, disturbed, bulk)?`;
      } else if (/No samples detected/i.test(text)) {
        q = "Can you provide the sample depths and types?";
      } else if ((m = text.match(/^Water\s+(\d+): depth not detected/i))) {
        q = `What is the water depth for water observation ${m[1]}?`;
      } else if (/No water observations detected/i.test(text)) {
        q = "Did you observe any groundwater or seepage? If so, at what depth?";
      } else if ((m = text.match(/^Test\s+(\d+): depth not detected/i))) {
        q = `What is the depth for test ${m[1]}?`;
      } else if ((m = text.match(/^Test\s+(\d+): type not detected/i))) {
        q = `What is the test type for test ${m[1]} (SPT, vane, CPT)?`;
      } else if ((m = text.match(/^Test\s+(\d+): result not detected/i))) {
        q = `What is the test result for test ${m[1]} (e.g., N=15)?`;
      } else if (/No tests detected/i.test(text)) {
        q = "Were any tests performed? If so, what type and depth?";
      } else if (/No items detected in mixed entry/i.test(text)) {
        q = "Can you restate the items observed (strata, samples, water, tests)?";
      } else {
        q = "Can you clarify: " + text.replace(/\.$/, "") + "?";
      }
      questions.push(q);
    }
    return normalizeQuestions(questions);
  }

  function renderPillsFromParsed(parsed) {
    const el = $("pills");
    el.innerHTML = "";
    const add = (txt, cls="") => {
      const s = document.createElement("span");
      s.className = ("pill " + cls).trim();
      s.textContent = txt;
      el.appendChild(s);
    };
    if (!parsed) return;
    const type = parsed.entry_type || "note";
    add("Type: " + type, "ok");
    if (type === "mixed") {
      const items = parsed.items || [];
      add("Items: " + items.length, items.length ? "ok" : "warn");
      const types = [...new Set(items.map(i => i.entry_type).filter(Boolean))];
      add("Types: " + (types.join(", ") || "(missing)"), types.length ? "ok" : "warn");
      const depths = [];
      for (const item of items) {
        if (!item) continue;
        if (item.entry_type === "strata") {
          const layers = item.layers || (item.layer ? [item.layer] : []);
          for (const l of layers) {
            if (isFiniteNumber(l.from)) depths.push(l.from);
            if (isFiniteNumber(l.to)) depths.push(l.to);
          }
        } else if (item.entry_type === "sample") {
          const list = item.samples || (item.sample ? [item.sample] : []);
          for (const s of list) {
            if (isFiniteNumber(s.depth)) depths.push(s.depth);
            if (isFiniteNumber(s.from)) depths.push(s.from);
            if (isFiniteNumber(s.to)) depths.push(s.to);
          }
        } else if (item.entry_type === "water") {
          const list = item.waters || (item.water ? [item.water] : []);
          for (const w of list) {
            if (isFiniteNumber(w.depth)) depths.push(w.depth);
            if (isFiniteNumber(w.from)) depths.push(w.from);
            if (isFiniteNumber(w.to)) depths.push(w.to);
          }
        } else if (item.entry_type === "test") {
          const list = item.tests || (item.test ? [item.test] : []);
          for (const t of list) {
            if (isFiniteNumber(t.depth)) depths.push(t.depth);
            if (isFiniteNumber(t.from)) depths.push(t.from);
            if (isFiniteNumber(t.to)) depths.push(t.to);
          }
        }
      }
      if (depths.length) {
        add("Depth span: " + formatDepthRange(Math.min(...depths), Math.max(...depths)), "ok");
      }
    } else if (type === "strata") {
      if (parsed.layers && parsed.layers.length) {
        const span = parsed.depth || { from: null, to: null, basis: "none" };
        const primaries = [...new Set(parsed.layers.map(l => l.bs5930?.primary || l.material).filter(Boolean))];
        add("Layers: " + parsed.layers.length, "ok");
        add("Depth span: " + formatDepthRange(span.from, span.to), (span.from == null || span.to == null) ? "warn" : "ok");
        add("Primary: " + (primaries.join(", ") || "(missing)"), primaries.length ? "ok" : "warn");
      } else {
        const d = parsed.depth || { from: null, to: null, basis: "none" };
        const bs = parsed.bs5930 || {};
        add("Depth: " + formatDepthRange(d.from, d.to), d.basis === "none" ? "warn" : "ok");
        add("Primary: " + (bs.primary || "(missing)"), bs.primary ? "ok" : "warn");
        add("Moisture: " + (bs.moisture || "(missing)"), bs.moisture ? "ok" : "warn");
        const cons = bs.consistency || bs.density;
        add("Consistency/Density: " + (cons || "(missing)"), cons ? "ok" : "warn");
        add("Color: " + (bs.color || "(missing)"), bs.color ? "ok" : "warn");
      }
    } else if (type === "sample") {
      const items = parsed.samples && parsed.samples.length ? parsed.samples : (parsed.sample ? [parsed.sample] : []);
      add("Samples: " + items.length, items.length ? "ok" : "warn");
      const depths = items.map(s => s.depth ?? s.from ?? s.to).filter(isFiniteNumber);
      if (depths.length) {
        add("Depth span: " + formatDepthRange(Math.min(...depths), Math.max(...depths)), "ok");
      }
      const types = [...new Set(items.map(s => s.type).filter(Boolean))];
      add("Types: " + (types.join(", ") || "(missing)"), types.length ? "ok" : "warn");
    } else if (type === "water") {
      const items = parsed.waters && parsed.waters.length ? parsed.waters : (parsed.water ? [parsed.water] : []);
      add("Water obs: " + items.length, items.length ? "ok" : "warn");
      const depths = items.map(w => w.depth ?? w.from ?? w.to).filter(isFiniteNumber);
      if (depths.length) {
        add("Depth span: " + formatDepthRange(Math.min(...depths), Math.max(...depths)), "ok");
      }
      const conds = [...new Set(items.map(w => w.condition).filter(Boolean))];
      add("Conditions: " + (conds.join(", ") || "noted"), "ok");
    } else if (type === "test") {
      const items = parsed.tests && parsed.tests.length ? parsed.tests : (parsed.test ? [parsed.test] : []);
      add("Tests: " + items.length, items.length ? "ok" : "warn");
      const depths = items.map(t => t.depth ?? t.from ?? t.to).filter(isFiniteNumber);
      if (depths.length) {
        add("Depth span: " + formatDepthRange(Math.min(...depths), Math.max(...depths)), "ok");
      }
      const types = [...new Set(items.map(t => t.type).filter(Boolean))];
      add("Types: " + (types.join(", ") || "(missing)"), types.length ? "ok" : "warn");
    } else if (type === "note") {
      add("Note: " + (parsed.note?.text || parsed.raw || ""), "ok");
    }
  }

  function renderPrompts(prompts) {
    const el = $("prompts");
    el.innerHTML = "";
    if (!prompts.length) {
      const d = document.createElement("div");
      d.className = "muted";
      d.textContent = "No prompts.";
      el.appendChild(d);
      return;
    }
    for (const p of prompts) {
      const div = document.createElement("div");
      div.className = "card " + (p.level === "warn" ? "warn" : "ok");
      div.style.padding = "10px";
      div.innerHTML = "<div><strong>" + p.level.toUpperCase() + "</strong>: " + p.text + "</div>";
      el.appendChild(div);
    }
  }

  function normalizeQuestions(list) {
    if (!Array.isArray(list)) return [];
    const out = [];
    const seen = new Set();
    for (const q of list) {
      const text = normalizeText(String(q || ""));
      if (!text) continue;
      const key = text.toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(text);
    }
    return out;
  }

  function renderFollowups(questions) {
    const el = $("followups");
    if (!el) return;
    el.innerHTML = "";
    if (!questions || !questions.length) {
      const d = document.createElement("div");
      d.className = "muted";
      d.textContent = "No follow-up questions.";
      el.appendChild(d);
      return;
    }
    for (const q of questions) {
      const div = document.createElement("div");
      div.className = "card";
      div.style.padding = "10px";
      div.innerHTML = "<div><strong>QUESTION</strong>: " + q + "</div>";
      el.appendChild(div);
    }
  }

  function normalizeChatText(text) {
    return String(text || "").replace(/\s+\n/g, "\n").replace(/\n\s+/g, "\n").trim();
  }

  function renderChat() {
    const el = $("chatThread");
    if (!el) return;
    el.innerHTML = "";
    if (!state.chat.length) {
      const empty = document.createElement("div");
      empty.className = "chat-empty";
      empty.textContent = "No messages yet. Your conversation will appear here.";
      el.appendChild(empty);
      return;
    }
    for (const msg of state.chat) {
      const row = document.createElement("div");
      row.className = "chat-message " + (msg.role === "user" ? "user" : "assistant");
      const bubble = document.createElement("div");
      bubble.className = "chat-bubble";
      bubble.textContent = msg.text;
      row.appendChild(bubble);
      el.appendChild(row);
    }
    el.scrollTop = el.scrollHeight;
  }

  function appendChatMessage(role, text, options = {}) {
    const cleaned = normalizeChatText(text);
    if (!cleaned) return;
    const key = options.key || null;
    if (key && state.chat.some((m) => m.key === key)) return;
    const last = state.chat[state.chat.length - 1];
    if (!key && last && last.role === role && last.text === cleaned) return;
    const messageRole = role || "assistant";
    state.chat.push({
      id: "C" + (state.chat.length + 1),
      role: messageRole,
      text: cleaned,
      timestamp: options.timestamp || new Date().toISOString(),
      kind: options.kind || null,
      key
    });
    renderChat();
    if (messageRole === "assistant") {
      const transcript = $("txtTranscript");
      if (transcript) {
        transcript.value = "";
        transcript.focus();
      }
    }
  }

  function clearChat() {
    state.chat = [];
    renderChat();
  }

  function appendFollowupChatMessage(questions) {
    const list = normalizeQuestions(questions);
    if (!list.length) return;
    const key = "followups:" + list.join("|").toLowerCase();
    const text = "Follow-up questions:\n" + list.map(q => "- " + q).join("\n");
    appendChatMessage("assistant", text, { kind: "followups", key });
  }

  function formatDepthForItem(item) {
    if (!item) return "? m";
    if (isFiniteNumber(item.depth)) return formatDepthSingle(item.depth);
    if (isFiniteNumber(item.from) || isFiniteNumber(item.to)) return formatDepthSpan(item.from, item.to);
    return "? m";
  }

  function formatParsedSummary(parsed) {
    if (!parsed || !parsed.entry_type) return "";
    const type = parsed.entry_type;
    if (type === "strata") {
      const layers = parsed.layers || (parsed.layer ? [parsed.layer] : []);
      if (!layers.length) return "No strata detected yet.";
      const lines = layers.map((l, idx) => {
        const id = l.id || l.horizon_id || ("L" + (idx + 1));
        const depth = formatDepthSpan(l.from, l.to);
        const bs = l.bs5930 || {};
        const label = bs.description || l.description || (bs.primary || l.material || "UNKNOWN");
        return `- ${id} ${depth}: ${label}`;
      });
      return "Parsed strata:\n" + lines.join("\n");
    }
    if (type === "sample") {
      const items = parsed.samples || (parsed.sample ? [parsed.sample] : []);
      if (!items.length) return "No samples detected yet.";
      const lines = items.map((s, idx) => {
        const id = s.id || ("S" + (idx + 1));
        const depth = formatDepthForItem(s);
        const label = [s.type].filter(Boolean).join(" ");
        return `- ${id} ${depth}${label ? " (" + label + ")" : ""}`;
      });
      return "Parsed samples:\n" + lines.join("\n");
    }
    if (type === "water") {
      const items = parsed.waters || (parsed.water ? [parsed.water] : []);
      if (!items.length) return "No water observations detected yet.";
      const lines = items.map((w, idx) => {
        const depth = formatDepthForItem(w);
        const label = w.condition || w.remark || "noted";
        return `- Water ${idx + 1} ${depth}: ${label}`;
      });
      return "Parsed water observations:\n" + lines.join("\n");
    }
    if (type === "test") {
      const items = parsed.tests || (parsed.test ? [parsed.test] : []);
      if (!items.length) return "No tests detected yet.";
      const lines = items.map((t, idx) => {
        const depth = formatDepthForItem(t);
        const label = [t.type, t.result].filter(Boolean).join(" ");
        return `- Test ${idx + 1} ${depth}${label ? " (" + label + ")" : ""}`;
      });
      return "Parsed tests:\n" + lines.join("\n");
    }
    if (type === "mixed") {
      const items = parsed.items || [];
      const types = [...new Set(items.map(i => i.entry_type).filter(Boolean))];
      return `Parsed mixed entry with ${items.length} items (${types.join(", ") || "untyped"}).`;
    }
    if (type === "note") {
      const text = parsed.note?.text || parsed.raw || "";
      return text ? ("Note captured: " + text) : "Note captured.";
    }
    return "";
  }

  function appendAssistantSummary(parsed) {
    const text = formatParsedSummary(parsed);
    if (!text) return;
    const key = "summary:" + text.toLowerCase();
    appendChatMessage("assistant", text, { kind: "summary", key });
  }

  function mergeDraftRaw(baseRaw, followupRaw) {
    const base = normalizeText(baseRaw || "");
    const next = normalizeText(followupRaw || "");
    if (!base) return next;
    if (!next) return base;
    if (base.toLowerCase().includes(next.toLowerCase())) return base;
    return base + " | " + next;
  }

  function setPendingFollowups(questions) {
    aiState.pendingFollowups = normalizeQuestions(questions);
  }

  function clearPendingFollowups() {
    aiState.pendingFollowups = [];
  }

  function getPendingFollowups() {
    return Array.isArray(aiState.pendingFollowups) ? aiState.pendingFollowups : [];
  }

  function buildReviewHtml(parsed) {
    if (!parsed) return "";
    const type = parsed.entry_type || "note";
    const pieces = [];
    if (type === "strata") {
      const layers = (parsed.layers && parsed.layers.length) ? parsed.layers : (parsed.layer ? [parsed.layer] : []);
      if (!layers.length) return "<div class=\"review-muted\">No strata detected.</div>";
      pieces.push("<table class=\"review-table\"><thead><tr>" +
        "<th>Layer</th><th>From</th><th>To</th><th>Primary</th><th>Secondary</th><th>Color</th>" +
        "<th>Moisture</th><th>Cons/Density</th><th>Description</th></tr></thead><tbody>");
      layers.forEach((layer, idx) => {
        const bs = layer.bs5930 || {};
        const cons = bs.consistency || bs.density || "";
        const secondary = (bs.secondary || []).join(" ");
        const inferred = layer.inferred_from_context ? " <span class=\"review-badge\">inferred</span>" : "";
        const label = layer.id || (idx + 1);
        pieces.push("<tr>" +
          "<td>" + label + inferred + "</td>" +
          "<td>" + formatDepthValue(layer.from) + "</td>" +
          "<td>" + formatDepthValue(layer.to) + "</td>" +
          "<td>" + (bs.primary || layer.material || "") + "</td>" +
          "<td>" + secondary + "</td>" +
          "<td>" + (bs.color || "") + "</td>" +
          "<td>" + (bs.moisture || "") + "</td>" +
          "<td>" + cons + "</td>" +
          "<td>" + (bs.description || "") + "</td>" +
          "</tr>");
      });
      pieces.push("</tbody></table>");
    } else if (type === "sample") {
      const items = parsed.samples && parsed.samples.length ? parsed.samples : (parsed.sample ? [parsed.sample] : []);
      pieces.push("<table class=\"review-table\"><thead><tr><th>#</th><th>Depth</th><th>Type</th><th>ID</th><th>Raw</th></tr></thead><tbody>");
      items.forEach((s, idx) => {
        const depthLabel = s.depth != null ? formatDepthSingle(s.depth) : formatDepthRange(s.from, s.to);
        pieces.push("<tr><td>" + (idx + 1) + "</td><td>" + depthLabel + "</td><td>" + (s.type || "") + "</td><td>" + (s.id || "") + "</td><td>" + (s.raw || "") + "</td></tr>");
      });
      pieces.push("</tbody></table>");
    } else if (type === "water") {
      const items = parsed.waters && parsed.waters.length ? parsed.waters : (parsed.water ? [parsed.water] : []);
      pieces.push("<table class=\"review-table\"><thead><tr><th>#</th><th>Depth</th><th>Condition</th><th>Time</th><th>Remark</th></tr></thead><tbody>");
      items.forEach((w, idx) => {
        const depthLabel = w.depth != null ? formatDepthSingle(w.depth) : formatDepthRange(w.from, w.to);
        const timeLabel = w.time_minutes != null ? (w.time_minutes + " min") : "";
        pieces.push("<tr><td>" + (idx + 1) + "</td><td>" + depthLabel + "</td><td>" + (w.condition || "") + "</td><td>" + timeLabel + "</td><td>" + (w.remark || w.raw || "") + "</td></tr>");
      });
      pieces.push("</tbody></table>");
    } else if (type === "test") {
      const items = parsed.tests && parsed.tests.length ? parsed.tests : (parsed.test ? [parsed.test] : []);
      pieces.push("<table class=\"review-table\"><thead><tr><th>#</th><th>Depth</th><th>Type</th><th>Result</th><th>Raw</th></tr></thead><tbody>");
      items.forEach((t, idx) => {
        const depthLabel = t.depth != null ? formatDepthSingle(t.depth) : formatDepthRange(t.from, t.to);
        pieces.push("<tr><td>" + (idx + 1) + "</td><td>" + depthLabel + "</td><td>" + (t.type || "") + "</td><td>" + (t.result || "") + "</td><td>" + (t.raw || "") + "</td></tr>");
      });
      pieces.push("</tbody></table>");
    } else {
      const text = parsed.note?.text || parsed.raw || "";
      pieces.push("<div class=\"review-muted\">" + (text || "No details.") + "</div>");
    }
    return pieces.join("");
  }

  function renderReview(parsed) {
    const el = $("review");
    if (!el) return;
    if (!parsed) {
      el.textContent = "Nothing to review yet.";
      el.className = "review-muted";
      return;
    }
    if (parsed.entry_type === "mixed" && parsed.items && parsed.items.length) {
      const blocks = parsed.items.map((item, idx) => {
        const header = "<div class=\"review-badge\">Item " + (idx + 1) + ": " + (item.entry_type || "note") + "</div>";
        return "<div class=\"card\" style=\"padding:8px; margin-bottom:8px;\">" + header + buildReviewHtml(item) + "</div>";
      });
      el.className = "";
      el.innerHTML = blocks.join("");
      return;
    }
    el.className = "";
    el.innerHTML = buildReviewHtml(parsed);
  }

  function parseEntryRaw(raw, entryTypeOverride, options = {}) {
    const entryType = detectEntryType(raw, entryTypeOverride, options);
    const timestamp = new Date().toISOString();
    let parsed = { timestamp, raw, entry_type: entryType };
    const allowMixed = options.allowMixed !== false;
    if (allowMixed && (!entryTypeOverride || entryTypeOverride === "auto") && entryType !== "mixed") {
      const signals = detectTypeSignals(raw);
      if (signals.totalCount > 1) {
        const items = parseMixedFromText(raw);
        const types = new Set(items.map(item => item.entry_type).filter(Boolean));
        if (types.size > 1) {
          parsed = { timestamp, raw, entry_type: "mixed", items };
          return parsed;
        }
      }
    }
    if (entryType === "mixed") {
      const items = parseMixedFromText(raw);
      if (items.length <= 1) return items[0] || parsed;
      parsed = { ...parsed, items };
      return parsed;
    }
    if (entryType === "strata") {
      const layers = parseStrataLayersFromText(raw);
      const explicitId = extractHorizonId(raw);
      if (explicitId && layers.length) {
        layers[0].id = explicitId;
        layers[0].explicit_id = true;
      }
      const froms = layers.map(l => l.from).filter(isFiniteNumber);
      const tos = layers.map(l => l.to).filter(isFiniteNumber);
      const depth = {
        from: froms.length ? Math.min(...froms) : null,
        to: tos.length ? Math.max(...tos) : null,
        basis: "rules layers"
      };
      parsed = {
        ...parsed,
        depth,
        layers,
        layer: layers.length ? layers[0] : null,
        bs5930: layers.length === 1 ? layers[0].bs5930 : null
      };
    } else if (entryType === "sample") {
      const samples = parseSamplesFromText(raw);
      parsed = { ...parsed, samples, sample: samples[0] || null };
    } else if (entryType === "water") {
      const waters = parseWatersFromText(raw);
      parsed = { ...parsed, waters, water: waters[0] || null };
    } else if (entryType === "test") {
      const tests = parseTestsFromText(raw);
      parsed = { ...parsed, tests, test: tests[0] || null };
    } else {
      parsed = { ...parsed, note: { text: raw } };
    }
    return parsed;
  }

  function parseMixedExplicit(raw) {
    const items = parseMixedFromText(raw);
    return {
      timestamp: new Date().toISOString(),
      raw,
      entry_type: "mixed",
      items
    };
  }

  function parseMixedFromText(raw) {
    const signals = detectTypeSignals(raw);
    const hasMultipleDepths = countDepthMarkers(raw) >= 2;
    const allowAndSplit = hasMultipleDepths || signals.primaryCount > 1 || (signals.strata && signals.primaryCount === 1);
    const includeComma = hasMultipleDepths || signals.primaryCount > 1;
    const baseSegments = splitMultiItems(raw, allowAndSplit, includeComma);
    const expanded = [];
    for (const seg of baseSegments) {
      const subSegments = splitByPrimaryKeywords(seg);
      for (const sub of subSegments) {
        const cleaned = stripJoiners(sub);
        if (isMeaningfulSegment(cleaned)) expanded.push(cleaned);
      }
    }
    const segments = expanded.length ? expanded : baseSegments;
    const items = [];
    for (const seg of segments) {
      const item = parseEntryRaw(seg, "auto", { allowMixed: false });
      if (item) items.push(item);
    }
    if (!items.length) items.push(parseEntryRaw(raw, "auto", { allowMixed: false }));
    return items;
  }

  function analyzeRules(options = {}) {
    const updateFollowups = options.updateFollowups !== false;
    const logChat = options.logChat !== false;
    debug("Analyze (rules) clicked at " + new Date().toISOString());
    const raw = normalizeText($("txtTranscript").value);
    if (logChat) appendChatMessage("user", raw, { kind: "user" });
    const parsed = parseEntryRaw(raw, $("entryType").value, { allowMixed: true });
    const prompts = buildPrompts(parsed);
    const followups = buildFollowupQuestions(prompts);
    state.current = { mode: "rules", timestamp: parsed.timestamp, raw, entry_type: parsed.entry_type, parsed, prompts, confirmed: false };
    $("out").textContent = JSON.stringify(state.current, null, 2);
    renderPillsFromParsed(parsed);
    renderPrompts(prompts);
    if (updateFollowups) {
      setPendingFollowups(followups);
      renderFollowups(followups);
    } else if (!getPendingFollowups().length) {
      renderFollowups([]);
    }
    renderReview(parsed);
    $("btnConfirm").disabled = raw.length === 0;
    debug("Analyze (rules) completed.");
  }

  async function analyzeBest() {
    debug("Analyze (best guess) clicked at " + new Date().toISOString());
    const raw = normalizeText($("txtTranscript").value);
    if (!raw) {
      setDiag("Type or dictate something first.");
      return;
    }
    const pendingFollowups = getPendingFollowups();
    const hasPendingFollowups = pendingFollowups.length > 0;
    const draftParsed = state.current?.parsed || null;
    const noteDraft = hasPendingFollowups && draftParsed ? state.current : null;
    const hasRemote = remoteState.enabled && remoteState.apiKey;
    const canAI = hasRemote;

    if (noteDraft) {
      appendChatMessage("user", raw, { kind: "user" });
      aiState.lastLocal = state.current;
      if (draftParsed.entry_type === "strata" && hasRemote) {
        aiState.requestId += 1;
        beginAiRun();
        aiInterpretLayersOnline({ raw, requestId: aiState.requestId, followup: true });
        return;
      }
      const updated = applyFollowupToCurrent(raw);
      if (updated) {
        const prompts = buildPrompts(updated);
        const followups = buildFollowupQuestions(prompts);
        state.current = {
          ...state.current,
          mode: "rules-followup",
          timestamp: new Date().toISOString(),
          raw: mergeDraftRaw(state.current?.raw, raw),
          entry_type: updated.entry_type,
          parsed: updated,
          prompts,
          confirmed: false
        };
        $("out").textContent = JSON.stringify(state.current, null, 2);
        renderPillsFromParsed(updated);
        renderPrompts(prompts);
        setPendingFollowups(followups);
        renderFollowups(followups);
        renderReview(updated);
        appendAssistantSummary(updated);
        appendFollowupChatMessage(followups);
        $("btnConfirm").disabled = raw.length === 0;
        return;
      }
      setDiag("Follow-up received, but it could not be applied. Try rephrasing or enable AI.");
      return;
    }
    analyzeRules({ updateFollowups: false, logChat: true });
    aiState.lastLocal = state.current;
    const entryTypeOverride = $("entryType").value;
    const baseParsed = state.current?.parsed || null;
    const baseType = baseParsed?.entry_type || "note";

    if (entryTypeOverride !== "auto") {
      if (entryTypeOverride === "strata" && hasRemote) {
        aiState.requestId += 1;
        beginAiRun();
        aiInterpretLayersOnline({ raw, requestId: aiState.requestId });
        return;
      }
      const prompts = state.current?.prompts || [];
      const followups = buildFollowupQuestions(prompts);
      setPendingFollowups(followups);
      renderFollowups(followups);
      appendAssistantSummary(state.current?.parsed || null);
      appendFollowupChatMessage(followups);
      setAiStatus("AI: skipped (" + entryTypeOverride + ")");
      setAiProgressRunning(false);
      setAiButtons(false);
      return;
    }

    if (!canAI) {
      const prompts = state.current?.prompts || [];
      const followups = buildFollowupQuestions(prompts);
      setPendingFollowups(followups);
      renderFollowups(followups);
      appendAssistantSummary(state.current?.parsed || null);
      appendFollowupChatMessage(followups);
      setAiStatus("AI: not loaded");
      setAiProgressRunning(false);
      setAiButtons(false);
      return;
    }

    aiState.requestId += 1;
    beginAiRun();
    const requestId = aiState.requestId;
    const classify = await aiClassifyEntryTypeOnline({ raw, requestId });

    if (requestId !== aiState.requestId || aiState.canceled) {
      endAiRun("AI: canceled");
      return;
    }

    const aiType = normalizeEntryType(classify?.entry_type);
    if (aiType === "strata") {
      aiInterpretLayersOnline({ raw, requestId });
      return;
    }
    if (aiType) {
      const parsed = aiType === "mixed"
        ? parseMixedExplicit(raw)
        : parseEntryRaw(raw, aiType, { allowMixed: aiType === "mixed" });
      const prompts = buildPrompts(parsed);
      state.current = { mode: "ai-type", timestamp: parsed.timestamp, raw, entry_type: parsed.entry_type, parsed, prompts, confirmed: false };
      $("out").textContent = JSON.stringify(state.current, null, 2);
      renderPillsFromParsed(parsed);
      renderPrompts(prompts);
      const followups = buildFollowupQuestions(prompts);
      setPendingFollowups(followups);
      renderFollowups(followups);
      renderReview(parsed);
      appendAssistantSummary(parsed);
      appendFollowupChatMessage(followups);
      $("btnConfirm").disabled = raw.length === 0;
      if (hasRemote) setRemoteStatus("ready (" + remoteState.model + ")");
      endAiRun("AI: ready (" + parsed.entry_type + ")");
      return;
    }

    if (baseType === "strata") {
      aiInterpretLayersOnline({ raw, requestId });
      return;
    }
    endAiRun("AI: idle");
  }

  // ---------------- LLM integration (online) ----------------
  const normalizeApiBase = (url) => (url || "").trim().replace(/\/+$/, "");
  const setRemoteButtons = (enabled) => {
    const btnEnable = $("btnEnableRemote");
    const btnDisable = $("btnDisableRemote");
    if (btnEnable) btnEnable.disabled = enabled;
    if (btnDisable) btnDisable.disabled = !enabled;
  };
  const enableRemote = () => {
    const key = ($("remoteApiKey")?.value || "").trim();
    const model = ($("remoteModel")?.value || remoteState.model).trim();
    const baseUrl = normalizeApiBase($("remoteBase")?.value || remoteState.baseUrl);
    if (!key) {
      setDiag("Online LLM needs an API key.");
      setRemoteStatus("disabled (missing key)");
      updateTranscribeStatus();
      return;
    }
    remoteState.apiKey = key;
    remoteState.model = model || remoteState.model;
    remoteState.baseUrl = baseUrl || remoteState.baseUrl;
    remoteState.enabled = true;
    setRemoteButtons(true);
    setRemoteStatus("enabled (" + remoteState.model + ")");
    setDiag("");
    updateTranscribeStatus();
  };
  const disableRemote = () => {
    remoteState.enabled = false;
    remoteState.apiKey = "";
    const keyInput = $("remoteApiKey");
    if (keyInput) keyInput.value = "";
    setRemoteButtons(false);
    setRemoteStatus("disabled");
    updateTranscribeStatus();
  };

  function extractJSON(text) {
    // Try to find JSON object in the response (with or without code fences).
    const s = text || "";
    const fenced = s.match(/```json\s*([\s\S]*?)```/i) || s.match(/```\s*([\s\S]*?)```/);
    const candidate = fenced ? fenced[1] : s;
    // Find first { ... } block
    const start = candidate.indexOf("{");
    const end = candidate.lastIndexOf("}");
    if (start >= 0 && end > start) return candidate.slice(start, end + 1);
    return null;
  }

  function mapAiLayers(layers) {
    let lastTo = getLastStratumTo(state.log);
    const mapped = [];
    const baseIndex = state.log?.strata?.length || 0;
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      const rawText = normalizeText([layer.material, ...(layer.descriptors || [])].filter(Boolean).join(" "));
      const materials = guessMaterial(rawText);
      const qualifiers = detectQualifiers(rawText);
      const density = detectDensity(rawText);
      const color = layer.color || extractColor(rawText);
      const structure = extractStructure(rawText);
      const plasticity = detectPlasticity(rawText);
      const bs5930 = buildBS5930({ raw: rawText, materials, qualifiers, density, color, structure, plasticity });
      let from = layer.from ?? null;
      let to = layer.to ?? null;
      let inferred = false;
      const explicitId = layer.explicit_id === true || Boolean(layer.id);
      const hasDepth = from != null || to != null;
      const hasNext = i < layers.length - 1;
      if (!explicitId && !hasDepth && hasNext && bs5930.primary) {
        const existing = findExistingStratumByPrimary(bs5930.primary, state.log);
        if (existing && isFiniteNumber(existing.to)) {
          lastTo = existing.to;
          continue;
        }
      }
      if (from == null && to != null && lastTo != null) {
        from = lastTo;
        inferred = true;
      }
      if (from != null && to != null && to < from) {
        const tmp = from;
        from = to;
        to = tmp;
        inferred = true;
      }
      if (to != null) lastTo = to;
      mapped.push({
        ...layer,
        id: layer.id || ("H" + (baseIndex + mapped.length + 1)),
        explicit_id: explicitId,
        from,
        to,
        material: layer.material || bs5930.primary || "UNKNOWN",
        descriptors: layer.descriptors || [],
        bs5930,
        raw: rawText,
        inferred_from_context: layer.inferred_from_context || inferred
      });
    }
    return mapped;
  }

  function getLayerMaterialKey(layer) {
    return normalizeMaterialKey(layer?.bs5930?.primary || layer?.material);
  }

  function applyRuleInferences(mappedLayers, raw) {
    const ruleLayers = parseStrataLayersFromText(raw || "");
    if (!ruleLayers.length) return mappedLayers;
    const ruleByKey = new Map();
    for (const r of ruleLayers) {
      const key = getLayerMaterialKey(r);
      if (key && !ruleByKey.has(key)) ruleByKey.set(key, r);
    }
    for (let i = 0; i < mappedLayers.length; i++) {
      const layer = mappedLayers[i];
      if (layer.from != null || layer.to == null) continue;
      let match = null;
      if (ruleLayers.length === mappedLayers.length) match = ruleLayers[i];
      if (!match) {
        const key = getLayerMaterialKey(layer);
        match = key ? ruleByKey.get(key) : null;
      }
      if (match && isFiniteNumber(match.from)) {
        layer.from = match.from;
        layer.inferred_from_context = true;
      }
    }
    return mappedLayers;
  }

  function formatDepthSpan(from, to) {
    if (isFiniteNumber(from) && isFiniteNumber(to)) return formatDepthRange(from, to);
    if (isFiniteNumber(from)) return formatDepthSingle(from);
    if (isFiniteNumber(to)) return formatDepthSingle(to);
    return "? m";
  }

  function describeStratumForContext(layer) {
    const id = layer.horizon_id || layer.id || "H?";
    const depth = formatDepthSpan(layer.from, layer.to);
    const bs = layer.bs5930 || {};
    const primary = bs.primary || layer.material || "UNKNOWN";
    const secondary = (bs.secondary || []).join(" ");
    const cons = bs.consistency || bs.density || "";
    const extras = [bs.color, bs.moisture, cons, secondary].filter(Boolean).join(", ");
    const raw = layer.raw ? ("raw: " + truncateText(layer.raw, 120)) : "";
    const extraParts = [extras, raw].filter(Boolean).join("; ");
    return `${id}: ${depth}, ${primary}${extraParts ? ", " + extraParts : ""}`;
  }

  function buildLogContext(maxLayers = null) {
    const log = state.log || {};
    const counts = {
      strata: log.strata?.length || 0,
      samples: log.samples?.length || 0,
      water: log.water?.length || 0,
      tests: log.tests?.length || 0,
      notes: log.notes?.length || 0
    };
    if (!counts.strata && !counts.samples && !counts.water && !counts.tests && !counts.notes) return "";
    const lines = [];
    lines.push("Hole ID: " + (log.hole_id || "EH"));
    lines.push(`Counts: strata ${counts.strata}, samples ${counts.samples}, water ${counts.water}, tests ${counts.tests}, notes ${counts.notes}`);
    if (counts.strata) {
      const strata = [...log.strata].sort((a, b) => (a.from ?? a.to ?? 0) - (b.from ?? b.to ?? 0));
      const limit = Number.isFinite(maxLayers) ? maxLayers : strata.length;
      const limited = strata.slice(0, limit);
      lines.push("Strata:");
      for (const layer of limited) lines.push("- " + describeStratumForContext(layer));
      if (Number.isFinite(maxLayers) && strata.length > limited.length) {
        lines.push("- ...and " + (strata.length - limited.length) + " more");
      }
    }
    return lines.join("\n");
  }

  function buildDraftContext() {
    const parsed = state.current?.parsed;
    if (!parsed || !parsed.entry_type) return "";
    const type = parsed.entry_type;
    if (type === "strata") {
      const layers = parsed.layers || (parsed.layer ? [parsed.layer] : []);
      if (!layers.length) return "";
      const lines = ["Strata:"];
      for (const layer of layers) lines.push("- " + describeStratumForContext(layer));
      return lines.join("\n");
    }
    if (type === "sample") {
      const items = parsed.samples || (parsed.sample ? [parsed.sample] : []);
      if (!items.length) return "";
      const lines = ["Samples:"];
      items.forEach((s, idx) => {
        const id = s.id || ("S" + (idx + 1));
        const depth = formatDepthForItem(s);
        const label = s.type ? (", " + s.type) : "";
        lines.push(`- ${id}: ${depth}${label}`);
      });
      return lines.join("\n");
    }
    if (type === "water") {
      const items = parsed.waters || (parsed.water ? [parsed.water] : []);
      if (!items.length) return "";
      const lines = ["Water:"];
      items.forEach((w, idx) => {
        const depth = formatDepthForItem(w);
        const label = w.condition || w.remark || "noted";
        lines.push(`- Water ${idx + 1}: ${depth}, ${label}`);
      });
      return lines.join("\n");
    }
    if (type === "test") {
      const items = parsed.tests || (parsed.test ? [parsed.test] : []);
      if (!items.length) return "";
      const lines = ["Tests:"];
      items.forEach((t, idx) => {
        const depth = formatDepthForItem(t);
        const label = [t.type, t.result].filter(Boolean).join(" ");
        lines.push(`- Test ${idx + 1}: ${depth}${label ? ", " + label : ""}`);
      });
      return lines.join("\n");
    }
    if (type === "note") {
      const text = parsed.note?.text || parsed.raw || "";
      return text ? ("Note: " + text) : "";
    }
    return "";
  }

  function getLayerKey(layer) {
    return layer?.id || layer?.horizon_id || null;
  }

  function mergeDraftLayer(base, incoming) {
    const out = { ...(base || {}) };
    if (incoming) Object.assign(out, incoming);
    const baseKey = getLayerKey(base);
    if (!getLayerKey(out) && baseKey) {
      out.id = base?.id || out.id;
      out.horizon_id = base?.horizon_id || out.horizon_id;
    }
    if (!isFiniteNumber(incoming?.from) && isFiniteNumber(base?.from)) out.from = base.from;
    if (!isFiniteNumber(incoming?.to) && isFiniteNumber(base?.to)) out.to = base.to;
    if (!incoming?.material || incoming.material === "UNKNOWN") out.material = base?.material || out.material;
    if ((!Array.isArray(incoming?.descriptors) || !incoming.descriptors.length) && Array.isArray(base?.descriptors)) {
      out.descriptors = base.descriptors.slice();
    }
    if (!incoming?.raw && base?.raw) out.raw = base.raw;
    if (incoming?.inferred_from_context == null && base?.inferred_from_context != null) {
      out.inferred_from_context = base.inferred_from_context;
    }
    if (incoming?.confidence == null && base?.confidence != null) {
      out.confidence = base.confidence;
    }
    const mergedBs = mergeBs5930(base?.bs5930, incoming?.bs5930);
    if (mergedBs) {
      const nextDesc = formatBS5930Description(mergedBs);
      if (nextDesc && nextDesc !== "Unclassified") {
        mergedBs.description = nextDesc;
        out.description = nextDesc;
      } else if (base?.bs5930?.description) {
        mergedBs.description = base.bs5930.description;
        if (!out.description || out.description === "Unclassified") {
          out.description = base.bs5930.description;
        }
      }
      out.bs5930 = mergedBs;
    }
    return out;
  }

  function mergeFollowupLayers(mappedLayers, baseLayers) {
    if (!Array.isArray(baseLayers) || !baseLayers.length) return mappedLayers;
    const incoming = Array.isArray(mappedLayers) ? mappedLayers : [];
    const byId = new Map();
    const extras = [];
    for (const layer of incoming) {
      const key = getLayerKey(layer);
      if (key) byId.set(key, layer);
      else extras.push(layer);
    }
    const out = baseLayers.map((base) => {
      const key = getLayerKey(base);
      if (key && byId.has(key)) {
        const merged = mergeDraftLayer(base, byId.get(key));
        byId.delete(key);
        return merged;
      }
      return { ...(base || {}) };
    });
    const remaining = [...byId.values(), ...extras];
    if (!remaining.length) return out;
    if (!byId.size && extras.length === 1 && out.length) {
      out[out.length - 1] = mergeDraftLayer(out[out.length - 1], extras[0]);
      return out;
    }
    for (const layer of remaining) out.push(layer);
    return out;
  }

  function extractLayerIdFromQuestions(questions, layers) {
    const text = normalizeText((questions || []).join(" "));
    if (!text) return layers?.length ? (getLayerKey(layers[layers.length - 1]) || null) : null;
    const direct = text.match(/\bh\s*(\d+)\b/i);
    if (direct) return "H" + direct[1];
    const numeric = text.match(/\b(?:layer|horizon)\s+(\d+)\b/i);
    if (numeric) {
      const idx = parseInt(numeric[1], 10);
      if (Number.isFinite(idx) && layers?.length && layers[idx - 1]) {
        return getLayerKey(layers[idx - 1]) || ("H" + idx);
      }
      return "H" + numeric[1];
    }
    const ordinals = {
      first: 1, second: 2, third: 3, fourth: 4, fifth: 5,
      sixth: 6, seventh: 7, eighth: 8, ninth: 9, tenth: 10,
      one: 1, two: 2, three: 3, four: 4, five: 5,
      six: 6, seven: 7, eight: 8, nine: 9, ten: 10
    };
    const ordinalMatch = text.match(/\b(first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|one|two|three|four|five|six|seven|eight|nine|ten)\b/i);
    if (ordinalMatch) {
      const idx = ordinals[ordinalMatch[1].toLowerCase()];
      if (idx && layers?.length && layers[idx - 1]) {
        return getLayerKey(layers[idx - 1]) || ("H" + idx);
      }
      if (idx) return "H" + idx;
    }
    return layers?.length ? (getLayerKey(layers[layers.length - 1]) || null) : null;
  }

  function applyFollowupToCurrent(raw) {
    const parsed = state.current?.parsed;
    if (!parsed || parsed.entry_type !== "strata") return null;
    const layers = parsed.layers?.length
      ? parsed.layers.map((l) => ({ ...l, bs5930: { ...(l.bs5930 || {}) } }))
      : (parsed.layer ? [{ ...parsed.layer, bs5930: { ...(parsed.layer.bs5930 || {}) } }] : []);
    if (!layers.length) return null;
    const targetId = extractHorizonId(raw) || extractLayerIdFromQuestions(getPendingFollowups(), layers);
    let targetIndex = targetId ? layers.findIndex((l) => getLayerKey(l) === targetId) : -1;
    if (targetIndex < 0) targetIndex = layers.length - 1;
    const target = { ...layers[targetIndex], bs5930: { ...(layers[targetIndex].bs5930 || {}) } };
    const patch = extractStratumPatch(raw);
    if (!patch.hasAny) return null;

    if (isFiniteNumber(patch.from)) target.from = patch.from;
    if (isFiniteNumber(patch.to)) target.to = patch.to;

    const bs = { ...(target.bs5930 || {}) };
    let bsChanged = false;
    if (patch.materialMentioned && patch.primary) {
      target.material = patch.primary;
      bs.primary = patch.primary;
      bsChanged = true;
    }
    if (patch.secondaryMentioned) {
      bs.secondary = patch.secondary;
      bsChanged = true;
    } else if (patch.materialMentioned) {
      bs.secondary = [];
      bsChanged = true;
    }
    if (patch.color) { bs.color = patch.color; bsChanged = true; }
    if (patch.moisture) { bs.moisture = patch.moisture; bsChanged = true; }
    if (patch.consistency) { bs.consistency = patch.consistency; bsChanged = true; }
    if (patch.density) { bs.density = patch.density; bsChanged = true; }
    if (patch.plasticity) { bs.plasticity = patch.plasticity; bsChanged = true; }
    if (patch.structure && patch.structure.length) { bs.structure = patch.structure; bsChanged = true; }
    if (patch.other && patch.other.length) { bs.other = patch.other; bsChanged = true; }
    if (bsChanged) {
      const desc = formatBS5930Description(bs);
      if (desc && desc !== "Unclassified") {
        bs.description = desc;
        target.description = desc;
      }
    }
    target.bs5930 = bs;
    if (raw) target.raw = raw;
    layers[targetIndex] = target;
    const froms = layers.map(l => l.from).filter(isFiniteNumber);
    const tos = layers.map(l => l.to).filter(isFiniteNumber);
    const depth = {
      from: froms.length ? Math.min(...froms) : null,
      to: tos.length ? Math.max(...tos) : null,
      basis: parsed.depth?.basis || "followup"
    };
    return { ...parsed, layers, layer: layers[0] || null, depth };
  }

  const ENTRY_TYPES = ["strata", "sample", "water", "test", "note", "mixed"];

  function normalizeEntryType(value) {
    const t = String(value || "").trim().toLowerCase();
    if (!t) return null;
    if (t === "samples") return "sample";
    if (t === "tests") return "test";
    if (t === "waters") return "water";
    if (t === "layers" || t === "layer") return "strata";
    if (t === "remarks" || t === "remark" || t === "details" || t === "detailed remarks") return "note";
    if (ENTRY_TYPES.includes(t)) return t;
    return null;
  }

  function parseEntryTypeResponse(text) {
    const jsonStr = extractJSON(text);
    if (!jsonStr) return null;
    let obj = null;
    try {
      obj = JSON.parse(jsonStr);
    } catch {
      return null;
    }
    const entryType = normalizeEntryType(obj.entry_type || obj.type);
    if (!entryType) return null;
    const confidence = typeof obj.confidence === "number" ? obj.confidence : null;
    return { entry_type: entryType, confidence };
  }

  function buildTypePrompt(raw) {
    const system = `You are a geotechnical logging assistant. Classify the input into one entry type.
Return ONLY valid JSON. Do not include markdown, explanations, or extra keys.
Allowed entry_type values: strata, sample, water, test, note, mixed.
If the text describes more than one type, use mixed.
Detailed remarks or observations with no strata/sample/water/test should be note.`;
    const context = buildLogContext();
    const contextBlock = context ? `\n\nExisting log context:\n${context}` : "";
    const user = `Input description:\n${raw}${contextBlock}\n\nOutput schema:\n{
  "entry_type": "strata|sample|water|test|note|mixed",
  "confidence": number
}`;
    return { system, user };
  }

  function buildAiPrompt(raw) {
    const system = `You are a geotechnical logging assistant. Convert natural language into structured depth intervals.
Return ONLY valid JSON. Do not include markdown, explanations, or extra keys.
Rules:
- Ground level/GL/surface means 0.0 m
- 'Underlain by' means the next layer starts at the previous layer's base depth
  - If a layer only states an end depth (e.g., 'to 0.8 m'), infer start depth from context when possible
  - Convert spoken decimals like 'point eight' to 0.8
  - If a depth or boundary is ambiguous, set confidence < 0.7 and include inferred_from_context true where applicable
  - Prefer BS 5930 style terms in material/descriptors when explicit in the text
  - Never invent new depths not implied by the text
  - If the user says a layer is NOT a material, do not set that material as primary
  - Ask follow-up questions whenever key details are missing or ambiguous (depths, materials, moisture/consistency)
  - If you need clarification, return questions and leave layers empty
  - If pending follow-up questions are provided, treat the input as answers and update the draft entry
  - If the user references an ordinal layer (e.g., "second layer"), map it to the matching horizon id from context (e.g., H2)
  - Use existing log context to resolve references like "H1" or "horizon 1"; include "id" only when referencing an existing horizon
  - If the user asks for a minor update to an existing horizon, only include the fields they asked to change and leave other fields null`;

    const context = buildLogContext();
    const contextBlock = context ? `\n\nExisting log context:\n${context}` : "";
    const pendingFollowups = getPendingFollowups();
    const followupBlock = pendingFollowups.length
      ? `\n\nPending follow-up questions (the user is responding now):\n- ${pendingFollowups.join("\n- ")}`
      : "";
    const draftContext = pendingFollowups.length ? buildDraftContext() : "";
    const draftBlock = draftContext ? `\n\nDraft entry context (not yet confirmed):\n${draftContext}` : "";
    const user = `Input description:\n${raw}${followupBlock}${draftBlock}${contextBlock}\n\nOutput schema:\n{
    "layers": [
      {
        "id": string|null,
        "color": string|null,
        "from": number|null,
        "to": number|null,
        "material": string|null,
        "descriptors": string[],
        "confidence": number,
        "inferred_from_context": boolean
      }
    ],
    "questions": string[]
  }`;
    return { system, user };
  }

  async function aiClassifyEntryTypeOnline(options = {}) {
    const raw = normalizeText(options.raw || $("txtTranscript").value);
    const requestId = options.requestId ?? null;
    if (!raw) return null;
    if (!remoteState.enabled || !remoteState.apiKey) return null;
    setRemoteStatus("classifying");
    setAiStatus("AI: classifying");
    debug("AI classify (online) started at " + new Date().toISOString());
    const { system, user } = buildTypePrompt(raw);
    const base = normalizeApiBase(remoteState.baseUrl);
    const url = base.endsWith("/chat/completions") ? base : (base + "/chat/completions");
    const controller = new AbortController();
    aiState.abortController = controller;

    try {
      const res = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + remoteState.apiKey
        },
        body: JSON.stringify({
          model: remoteState.model,
          messages: [
            { role: "system", content: system },
            { role: "user", content: user }
          ],
          temperature: 0,
          max_tokens: 120
        }),
        signal: controller.signal
      });

      const rawText = await res.text();
      let data = null;
      try {
        data = JSON.parse(rawText);
      } catch {
        data = null;
      }
      if (!res.ok) {
        const msg = data?.error?.message || rawText || res.statusText;
        throw new Error("Online LLM error (" + res.status + "): " + msg);
      }

      const text = data?.choices?.[0]?.message?.content || "";
      debug("Online AI classify response: " + text.slice(0, 200));
      if (requestId !== null && requestId !== aiState.requestId) return null;
      if (aiState.canceled) return null;
      return parseEntryTypeResponse(text);
    } catch (e) {
      const msg = e?.name === "AbortError" ? "canceled" : (e?.message || e);
      debug("Online AI classify failed: " + msg);
      return null;
    }
  }

  async function aiInterpretLayersOnline(options = {}) {
    const raw = normalizeText(options.raw || $("txtTranscript").value);
    const requestId = options.requestId ?? null;
    if (!raw) {
      setDiag("Type or dictate something first.");
      return;
    }
    if (!remoteState.enabled || !remoteState.apiKey) {
      setRemoteStatus("disabled");
      setDiag("Online LLM is not enabled.");
      endAiRun("AI: idle");
      return;
    }
    setRemoteStatus("thinking");
    debug("AI interpret (online) started at " + new Date().toISOString());
    const { system, user } = buildAiPrompt(raw);
    const base = normalizeApiBase(remoteState.baseUrl);
    const url = base.endsWith("/chat/completions") ? base : (base + "/chat/completions");
    const controller = new AbortController();
    aiState.abortController = controller;

    try {
      const res = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + remoteState.apiKey
        },
        body: JSON.stringify({
          model: remoteState.model,
          messages: [
            { role: "system", content: system },
            { role: "user", content: user }
          ],
          temperature: 0,
          max_tokens: 512
        }),
        signal: controller.signal
      });

      const rawText = await res.text();
      let data = null;
      try {
        data = JSON.parse(rawText);
      } catch {
        data = null;
      }
      if (!res.ok) {
        const msg = data?.error?.message || rawText || res.statusText;
        throw new Error("Online LLM error (" + res.status + "): " + msg);
      }

      const text = data?.choices?.[0]?.message?.content || "";
      debug("Online AI raw response: " + text.slice(0, 500) + (text.length > 500 ? "." : ""));
      const jsonStr = extractJSON(text);
      if (!jsonStr) throw new Error("Could not find JSON in model response.");
      const obj = JSON.parse(jsonStr);
      if (requestId !== null && requestId !== aiState.requestId) {
        debug("Online AI result ignored (superseded).");
        return;
      }
      if (aiState.canceled) {
        debug("Online AI result ignored (canceled).");
        endAiRun("AI: canceled");
        return;
      }
      const questions = normalizeQuestions(obj.questions);
      const hasLayers = Array.isArray(obj.layers) && obj.layers.length;
      if (!Array.isArray(obj.layers)) {
        if (questions.length) {
          setPendingFollowups(questions);
          renderFollowups(questions);
          appendFollowupChatMessage(questions);
          const fallback = aiState.lastLocal || state.current;
          if (fallback) {
            state.current = { ...fallback, ai_questions: questions };
            $("out").textContent = JSON.stringify(state.current, null, 2);
            renderPillsFromParsed(state.current.parsed);
            renderPrompts(state.current.prompts || []);
            renderReview(state.current.parsed);
          }
          $("btnConfirm").disabled = true;
          setDiag("AI needs clarification. Answer the follow-up question(s) and re-analyze.");
          endAiRun("AI: waiting on follow-up");
          return;
        }
        throw new Error("JSON missing 'layers' array.");
      }
      if (!hasLayers) {
        if (questions.length) {
          setPendingFollowups(questions);
          renderFollowups(questions);
          appendFollowupChatMessage(questions);
          const fallback = aiState.lastLocal || state.current;
          if (fallback) {
            state.current = { ...fallback, ai_questions: questions };
            $("out").textContent = JSON.stringify(state.current, null, 2);
            renderPillsFromParsed(state.current.parsed);
            renderPrompts(state.current.prompts || []);
            renderReview(state.current.parsed);
          }
          $("btnConfirm").disabled = true;
          setDiag("AI needs clarification. Answer the follow-up question(s) and re-analyze.");
          endAiRun("AI: waiting on follow-up");
          return;
        }
        throw new Error("JSON returned no layers.");
      }

      let mappedLayers = applyRuleInferences(mapAiLayers(obj.layers), raw);
      const followupActive = getPendingFollowups().length > 0 && state.current?.parsed?.entry_type === "strata";
      if (followupActive) {
        const baseLayers = state.current?.parsed?.layers || (state.current?.parsed?.layer ? [state.current.parsed.layer] : []);
        if (baseLayers.length) mappedLayers = mergeFollowupLayers(mappedLayers, baseLayers);
      }
      const explicitId = extractHorizonId(raw);
      if (explicitId && mappedLayers.length) {
        mappedLayers[0].id = mappedLayers[0].id || explicitId;
        mappedLayers[0].explicit_id = true;
      }
      const froms = mappedLayers.map(l => l.from).filter(isFiniteNumber);
      const tos = mappedLayers.map(l => l.to).filter(isFiniteNumber);
      const minFrom = froms.length ? Math.min(...froms) : null;
      const maxTo = tos.length ? Math.max(...tos) : null;
      const parsed = {
        entry_type: "strata",
        layers: mappedLayers,
        depth: { from: minFrom, to: maxTo, basis: "online ai layers" }
      };

      const prompts = buildPrompts(parsed);
      for (const [i, l] of mappedLayers.entries()) {
        if ((typeof l.confidence === "number" && l.confidence < 0.7) || l.inferred_from_context) {
          prompts.push({
            level: "warn",
            text: `Layer ${l.id || (i + 1)} needs confirmation (confidence ${l.confidence ?? "?"}).`
          });
        }
      }
      const followups = normalizeQuestions([...questions, ...buildFollowupQuestions(prompts)]);
      setPendingFollowups(followups);

      const entryRaw = followupActive ? mergeDraftRaw(state.current?.raw, raw) : raw;
      state.current = {
        mode: "ai-online",
        timestamp: new Date().toISOString(),
        raw: entryRaw,
        entry_type: "strata",
        parsed,
        ai_layers: obj.layers,
        ai_questions: followups,
        prompts
      };

      $("out").textContent = JSON.stringify(state.current, null, 2);
      renderPillsFromParsed(parsed);
      renderReview(parsed);
      renderFollowups(followups);
      renderPrompts(prompts);
      appendAssistantSummary(parsed);
      appendFollowupChatMessage(followups);

      $("btnConfirm").disabled = false;
      setRemoteStatus("ready (" + remoteState.model + ")");
      endAiRun("AI: ready");
      debug("Online AI interpret completed.");
    } catch (e) {
      const msg = e?.name === "AbortError" ? "canceled" : (e?.message || e);
      const hint = /failed to fetch|networkerror|cors/i.test(String(msg))
        ? " (check CORS or use a proxy server)."
        : "";
      setRemoteStatus("error");
      setDiag("Online AI failed: " + msg + hint);
      endAiRun(e?.name === "AbortError" ? "AI: canceled" : "AI: error");
      debug("Online AI interpret failed: " + msg);
    }
  }

  // ---------------- Borehole log ----------------
  const svgNS = "http://www.w3.org/2000/svg";

  function svgEl(name, attrs = {}) {
    const el = document.createElementNS(svgNS, name);
    for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }

  function addText(svg, x, y, text, attrs = {}) {
    const el = svgEl("text", { x, y, ...attrs });
    el.textContent = text;
    svg.appendChild(el);
    return el;
  }

  function addLine(svg, x1, y1, x2, y2, stroke, width = 1, dash = null) {
    const attrs = { x1, y1, x2, y2, stroke, "stroke-width": width };
    if (dash) attrs["stroke-dasharray"] = dash;
    const el = svgEl("line", attrs);
    svg.appendChild(el);
    return el;
  }

  function addRect(svg, x, y, w, h, fill, stroke) {
    const el = svgEl("rect", { x, y, width: w, height: h, fill, stroke });
    svg.appendChild(el);
    return el;
  }

  function addPolygon(svg, points, fill, stroke) {
    const el = svgEl("polygon", { points, fill, stroke });
    svg.appendChild(el);
    return el;
  }

  function pickMaterialColor(primary) {
    const key = (primary || "").toUpperCase();
    if (/\bSTONE\b|\bSHALE\b|\bMUDSTONE\b|\bSILTSTONE\b|\bBASALT\b|\bGRANITE\b/.test(key)) return "#b3b3b3";
    const map = {
      "TOPSOIL": "#6e4b2a",
      "MADE GROUND": "#9c8f7a",
      "CLAY": "#b06d3b",
      "SILT": "#c2b280",
      "SAND": "#e2c38b",
      "GRAVEL": "#b0a99f",
      "COBBLES": "#9aa0a6",
      "BOULDERS": "#8d9095",
      "PEAT": "#3b2f2f",
      "CHALK": "#f2f2f2",
      "ROCK": "#a3a3a3"
    };
    return map[key] || "#dddddd";
  }

  function chooseTick(maxDepth) {
    if (maxDepth <= 1) return 0.1;
    if (maxDepth <= 3) return 0.2;
    if (maxDepth <= 6) return 0.5;
    if (maxDepth <= 12) return 1;
    if (maxDepth <= 30) return 2;
    return 5;
  }

  function calcPxPerM(maxDepth) {
    if (maxDepth <= 2) return 160;
    if (maxDepth <= 5) return 120;
    if (maxDepth <= 10) return 90;
    if (maxDepth <= 20) return 70;
    return 50;
  }

  function getLogMaxDepth() {
    const depths = [];
    for (const l of state.log.strata) {
      if (isFiniteNumber(l.from)) depths.push(l.from);
      if (isFiniteNumber(l.to)) depths.push(l.to);
    }
    for (const s of state.log.samples) {
      if (isFiniteNumber(s.depth)) depths.push(s.depth);
      if (isFiniteNumber(s.from)) depths.push(s.from);
      if (isFiniteNumber(s.to)) depths.push(s.to);
    }
    for (const w of state.log.water) {
      if (isFiniteNumber(w.depth)) depths.push(w.depth);
      if (isFiniteNumber(w.from)) depths.push(w.from);
      if (isFiniteNumber(w.to)) depths.push(w.to);
    }
    for (const t of state.log.tests) {
      if (isFiniteNumber(t.depth)) depths.push(t.depth);
      if (isFiniteNumber(t.from)) depths.push(t.from);
      if (isFiniteNumber(t.to)) depths.push(t.to);
    }
    const max = depths.length ? Math.max(...depths) : 1;
    return Math.max(1, Math.ceil((max + 0.1) * 10) / 10);
  }

  function ensureHorizonIds(strata) {
    if (!Array.isArray(strata)) return;
    let idx = 1;
    for (const layer of strata) {
      if (!layer) continue;
      if (!layer.horizon_id) layer.horizon_id = "H" + idx;
      idx += 1;
    }
  }

  function renderLogData() {
    $("logData").textContent = JSON.stringify(state.log, null, 2);
  }

  function renderLog() {
    const svg = $("logSvg");
    if (!svg) return;
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    const maxDepth = getLogMaxDepth();
    const svgWidth = svg.clientWidth || 720;
    const svgHeight = svg.clientHeight || 800;
    const colX = 90;
    const colW = Math.max(140, Math.min(260, Math.round(svgWidth * 0.3)));
    const top = 24;
    const usableHeight = Math.max(120, svgHeight - top - 40);
    const pxPerM = maxDepth > 0 ? (usableHeight / maxDepth) : calcPxPerM(maxDepth);
    const colH = Math.max(120, Math.round(maxDepth * pxPerM));
    const bottom = top + colH;
    const width = svgWidth;
    const height = Math.max(svgHeight, bottom + 40);

    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.removeAttribute("height");
    svg.removeAttribute("width");

    addText(svg, 10, 14, "Hole: " + (state.log.hole_id || "EH"), { "font-size": "12", "font-weight": "bold", fill: "#222" });
    addText(svg, colX - 48, 14, "Depth (m)", { "font-size": "10", fill: "#555" });

    // Column outline
    addRect(svg, colX, top, colW, colH, "#ffffff", "#333");

    // Depth ticks
    const tick = chooseTick(maxDepth);
    for (let d = 0; d <= maxDepth + 1e-6; d += tick) {
      const y = top + (d * pxPerM);
      addLine(svg, colX - 6, y, colX, y, "#555", 1);
      addText(svg, colX - 10, y + 4, formatDepthValue(d), { "font-size": "10", "text-anchor": "end", fill: "#333" });
      addLine(svg, colX, y, colX + colW, y, "#eee", 1);
    }

    const hasData = state.log.strata.length || state.log.samples.length || state.log.water.length || state.log.tests.length;
    if (!hasData) {
      addText(svg, colX + 10, top + 20, "No log data yet.", { "font-size": "12", fill: "#666" });
      return;
    }

    // Strata
    const strata = [...state.log.strata].sort((a, b) => (a.from ?? a.to ?? 0) - (b.from ?? b.to ?? 0));
    for (const layer of strata) {
      let from = isFiniteNumber(layer.from) ? layer.from : null;
      let to = isFiniteNumber(layer.to) ? layer.to : null;
      if (from == null && to != null) from = Math.max(0, to - 0.1);
      if (to == null && from != null) to = from + 0.1;
      if (from == null || to == null) continue;
      const y = top + (from * pxPerM);
      const h = Math.max(6, (to - from) * pxPerM);
      const fill = pickMaterialColor(layer.bs5930?.primary || layer.material);
      addRect(svg, colX, y, colW, h, fill, "#666");
      const label = layer.bs5930?.description || layer.description || layer.material || "Layer";
      const midY = y + (h / 2) + 4;
      addLine(svg, colX + colW, midY - 4, colX + colW + 8, midY - 4, "#666", 1);
      addText(svg, colX + colW + 12, midY, label, { "font-size": "10", fill: "#222" });
    }

    // Samples
    for (const s of state.log.samples) {
      const depth = isFiniteNumber(s.depth) ? s.depth : (isFiniteNumber(s.from) ? s.from : null);
      if (!isFiniteNumber(depth)) continue;
      const y = top + (depth * pxPerM);
      const x = colX + colW + 6;
      const size = 6;
      const points = `${x},${y} ${x + size},${y - size} ${x + size},${y + size}`;
      addPolygon(svg, points, "#2f7ed8", "#1c5ea6");
      const label = "S: " + [s.id, s.type].filter(Boolean).join(" ");
      addText(svg, x + size + 6, y + 4, label, { "font-size": "10", fill: "#1c5ea6" });
    }

    // Water
    for (const w of state.log.water) {
      const depth = isFiniteNumber(w.depth) ? w.depth : (isFiniteNumber(w.from) ? w.from : null);
      if (!isFiniteNumber(depth) && w.condition === "dry") {
        addText(svg, colX + colW + 12, top + 12, "W: dry", { "font-size": "10", fill: "#0077b6" });
        continue;
      }
      if (!isFiniteNumber(depth)) continue;
      const y = top + (depth * pxPerM);
      addLine(svg, colX, y, colX + colW, y, "#0077b6", 2);
      const label = "W: " + (w.condition || "noted");
      addText(svg, colX + colW + 12, y + 4, label, { "font-size": "10", fill: "#0077b6" });
    }

    // Tests
    for (const t of state.log.tests) {
      const depth = isFiniteNumber(t.depth) ? t.depth : (isFiniteNumber(t.from) ? t.from : null);
      if (!isFiniteNumber(depth)) continue;
      const y = top + (depth * pxPerM);
      const x = colX + colW + 6;
      const size = 6;
      const points = `${x + size},${y} ${x + size * 2},${y + size} ${x + size},${y + size * 2} ${x},${y + size}`;
      addPolygon(svg, points, "#f4a261", "#c06a1a");
      const label = "T: " + [t.type, t.result].filter(Boolean).join(" ");
      addText(svg, x + size * 2 + 6, y + size + 4, label, { "font-size": "10", fill: "#c06a1a" });
    }
  }

  function setEditMode(active) {
    const isEditing = Boolean(active);
    $("btnConfirm").textContent = isEditing ? "Update entry" : "Confirm entry";
    $("btnCancelEdit").disabled = !isEditing;
  }

  function entrySummary(entry, index) {
    const type = entry.entry_type || entry.parsed?.entry_type || entry.mode || "note";
    if (type === "mixed") {
      const items = entry.parsed?.items || entry.items || [];
      if (!items.length) return `#${index + 1} mixed (0 items)`;
      const counts = { strata: 0, sample: 0, water: 0, test: 0, note: 0 };
      const depths = [];
      for (const item of items) {
        const itemType = item?.entry_type || "note";
        if (counts[itemType] != null) counts[itemType] += 1;
        if (itemType === "strata") {
          const layers = item.layers || (item.layer ? [item.layer] : []);
          for (const l of layers) {
            if (isFiniteNumber(l.from)) depths.push(l.from);
            if (isFiniteNumber(l.to)) depths.push(l.to);
          }
        } else if (itemType === "sample") {
          const list = item.samples || (item.sample ? [item.sample] : []);
          for (const s of list) {
            if (isFiniteNumber(s.depth)) depths.push(s.depth);
            if (isFiniteNumber(s.from)) depths.push(s.from);
            if (isFiniteNumber(s.to)) depths.push(s.to);
          }
        } else if (itemType === "water") {
          const list = item.waters || (item.water ? [item.water] : []);
          for (const w of list) {
            if (isFiniteNumber(w.depth)) depths.push(w.depth);
            if (isFiniteNumber(w.from)) depths.push(w.from);
            if (isFiniteNumber(w.to)) depths.push(w.to);
          }
        } else if (itemType === "test") {
          const list = item.tests || (item.test ? [item.test] : []);
          for (const t of list) {
            if (isFiniteNumber(t.depth)) depths.push(t.depth);
            if (isFiniteNumber(t.from)) depths.push(t.from);
            if (isFiniteNumber(t.to)) depths.push(t.to);
          }
        }
      }
      const countParts = Object.entries(counts).filter(([, v]) => v > 0).map(([k, v]) => `${k}:${v}`);
      const span = depths.length ? formatDepthRange(Math.min(...depths), Math.max(...depths)) : "?-? m";
      return `#${index + 1} mixed (${countParts.join(", ") || ("items: " + items.length)}) ${span}`.trim();
    }
    if (type === "strata") {
      const layers = entry.parsed?.layers || (entry.parsed?.layer ? [entry.parsed.layer] : []);
      const depth = entry.parsed?.depth || {};
      const primaries = layers.map(l => l.bs5930?.primary || l.material).filter(Boolean);
      return `#${index + 1} strata (${layers.length || 1} layer${layers.length === 1 ? "" : "s"}), ${formatDepthRange(depth.from, depth.to)}: ${primaries.join(", ")}`;
    }
    if (type === "sample") {
      const items = entry.parsed?.samples || (entry.parsed?.sample ? [entry.parsed.sample] : (entry.sample ? [entry.sample] : []));
      const depths = items.map(s => s.depth ?? s.from ?? s.to).filter(isFiniteNumber);
      const span = depths.length ? formatDepthRange(Math.min(...depths), Math.max(...depths)) : "?-? m";
      return `#${index + 1} sample (${items.length || 1}) ${span}`.trim();
    }
    if (type === "water") {
      const items = entry.parsed?.waters || (entry.parsed?.water ? [entry.parsed.water] : (entry.water ? [entry.water] : []));
      const depths = items.map(w => w.depth ?? w.from ?? w.to).filter(isFiniteNumber);
      const span = depths.length ? formatDepthRange(Math.min(...depths), Math.max(...depths)) : "?-? m";
      return `#${index + 1} water (${items.length || 1}) ${span}`.trim();
    }
    if (type === "test") {
      const items = entry.parsed?.tests || (entry.parsed?.test ? [entry.parsed.test] : (entry.test ? [entry.test] : []));
      const depths = items.map(t => t.depth ?? t.from ?? t.to).filter(isFiniteNumber);
      const span = depths.length ? formatDepthRange(Math.min(...depths), Math.max(...depths)) : "?-? m";
      return `#${index + 1} test (${items.length || 1}) ${span}`.trim();
    }
    return `#${index + 1} note ${entry.raw || ""}`.trim();
  }

  function renderEntryList() {
    const el = $("entryList");
    if (!el) return;
    el.innerHTML = "";
    if (!state.entries.length) {
      const d = document.createElement("div");
      d.className = "review-muted";
      d.textContent = "No confirmed entries yet.";
      el.appendChild(d);
      return;
    }
    state.entries.forEach((entry, index) => {
      const row = document.createElement("div");
      row.className = "card";
      row.style.padding = "8px";
      const summary = document.createElement("div");
      summary.textContent = entrySummary(entry, index);
      const actions = document.createElement("div");
      actions.className = "row3";
      actions.style.marginTop = "6px";
      const btnEdit = document.createElement("button");
      btnEdit.type = "button";
      btnEdit.textContent = "Edit";
      btnEdit.addEventListener("click", () => {
        state.editIndex = index;
        const typeValue = entry.entry_type === "mixed" ? "auto" : (entry.entry_type || "auto");
        $("entryType").value = typeValue;
        $("txtTranscript").value = entry.raw || "";
        analyzeRules();
        setEditMode(true);
        setDiag("Editing entry #" + (index + 1) + ". Adjust the transcript and re-analyze.");
      });
      const btnDelete = document.createElement("button");
      btnDelete.type = "button";
      btnDelete.textContent = "Delete";
      btnDelete.addEventListener("click", () => {
        state.entries.splice(index, 1);
        rebuildLogFromEntries();
        $("entries").textContent = JSON.stringify(state.entries, null, 2);
        renderEntryList();
        setEditMode(false);
      });
      actions.appendChild(btnEdit);
      actions.appendChild(btnDelete);
      row.appendChild(summary);
      row.appendChild(actions);
      el.appendChild(row);
    });
  }

  function rebuildLogFromEntries() {
    const holeId = state.log.hole_id;
    state.log = { hole_id: holeId, strata: [], samples: [], water: [], tests: [], notes: [] };
    for (const entry of state.entries) applyEntryToLog(entry);
    renderLogData();
    renderLog();
    schedulePersist("rebuild");
  }

  function findStratumIndexByHorizonId(id) {
    if (!id) return -1;
    return state.log.strata.findIndex((s) => s?.horizon_id === id || s?.id === id);
  }

  function mergeBs5930(existing, incoming) {
    const out = { ...(existing || {}) };
    if (!incoming) return out;
    for (const [key, value] of Object.entries(incoming)) {
      if (value == null) continue;
      if (key === "primary" && String(value).toUpperCase() === "UNKNOWN") continue;
      if (Array.isArray(value)) {
        if (!value.length) continue;
        out[key] = value.slice();
      } else {
        out[key] = value;
      }
    }
    return out;
  }

  function hasBsData(bs) {
    if (!bs) return false;
    return Boolean(
      bs.primary ||
      (bs.secondary && bs.secondary.length) ||
      bs.color ||
      bs.moisture ||
      bs.consistency ||
      bs.density ||
      bs.plasticity ||
      (bs.structure && bs.structure.length) ||
      (bs.other && bs.other.length)
    );
  }

  function applyEntryToLog(entry) {
    const type = entry.entry_type || entry.parsed?.entry_type;
    if (!type) return;
    if (type === "mixed") {
      const items = entry.parsed?.items || entry.items || [];
      for (const item of items) {
        if (!item || item.entry_type === "mixed") continue;
        applyEntryToLog({
          ...entry,
          entry_type: item.entry_type,
          parsed: item,
          raw: item.raw || entry.raw
        });
      }
      return;
    }
    if (type === "strata") {
      const layers = entry.parsed?.layers || entry.layers || (entry.parsed?.layer ? [entry.parsed.layer] : []);
      const preferAi = entry.mode === "ai" || entry.mode === "ai-online";
      for (const l of layers) {
        const hasDepth = l.from != null || l.to != null;
        const hasMaterial = Boolean(l.material || l.bs5930 || l.raw || entry.raw);
        const explicitId = l.explicit_id === true;
        if (!hasDepth && !hasMaterial && !explicitId) continue;
        const rawText = explicitId ? (entry.raw || l.raw || "") : (l.raw || entry.raw || "");
        const bs = l.bs5930 || buildBS5930({
          raw: rawText,
          materials: guessMaterial(rawText),
          qualifiers: detectQualifiers(rawText)
        });
        const horizonId = l.id || ("H" + (state.log.strata.length + 1));
        const patch = explicitId ? extractStratumPatch(rawText) : null;
        const usePatch = explicitId && patch && patch.hasAny;
        if (explicitId) {
          const existingIndex = findStratumIndexByHorizonId(horizonId);
          if (existingIndex >= 0) {
            const target = state.log.strata[existingIndex];
            const updated = { ...target };
            updated.horizon_id = horizonId;
            const aiBs = bs;
            const aiMaterial = l.material || aiBs.primary || null;
            const aiHasDepth = isFiniteNumber(l.from) || isFiniteNumber(l.to);
            const aiHasBs = hasBsData(aiBs);
            const aiHasUpdate = aiHasDepth || aiHasBs || (aiMaterial && aiMaterial !== "UNKNOWN");

            if (preferAi && aiHasUpdate) {
              if (isFiniteNumber(l.from)) updated.from = l.from;
              if (isFiniteNumber(l.to)) updated.to = l.to;
              if (aiMaterial && aiMaterial !== "UNKNOWN") updated.material = aiMaterial;
              if (aiHasBs) {
                const mergedBs = mergeBs5930(target.bs5930, aiBs);
                mergedBs.description = formatBS5930Description(mergedBs);
                updated.bs5930 = mergedBs;
                updated.description = mergedBs.description || updated.description;
              }
            } else if (usePatch) {
              if (isFiniteNumber(patch.from)) updated.from = patch.from;
              if (isFiniteNumber(patch.to)) updated.to = patch.to;
              const mergedBs = { ...(target.bs5930 || bs) };
              let bsChanged = false;
              if (patch.materialMentioned && patch.primary) {
                updated.material = patch.primary;
                mergedBs.primary = patch.primary;
                bsChanged = true;
              }
              if (patch.secondaryMentioned) {
                mergedBs.secondary = patch.secondary;
                bsChanged = true;
              } else if (patch.materialMentioned) {
                mergedBs.secondary = [];
                bsChanged = true;
              }
              if (patch.color) { mergedBs.color = patch.color; bsChanged = true; }
              if (patch.moisture) { mergedBs.moisture = patch.moisture; bsChanged = true; }
              if (patch.consistency) { mergedBs.consistency = patch.consistency; bsChanged = true; }
              if (patch.density) { mergedBs.density = patch.density; bsChanged = true; }
              if (patch.plasticity) { mergedBs.plasticity = patch.plasticity; bsChanged = true; }
              if (patch.structure && patch.structure.length) { mergedBs.structure = patch.structure; bsChanged = true; }
              if (patch.other && patch.other.length) { mergedBs.other = patch.other; bsChanged = true; }
              if (bsChanged) {
                mergedBs.description = formatBS5930Description(mergedBs);
                updated.bs5930 = mergedBs;
                updated.description = mergedBs.description || updated.description;
              }
            } else {
              const colorOnlyUpdate = !bs.primary && bs.color;
              if (isFiniteNumber(l.from)) updated.from = l.from;
              if (isFiniteNumber(l.to)) updated.to = l.to;
              const nextMaterial = l.material || bs.primary;
              if (nextMaterial && nextMaterial !== "UNKNOWN") updated.material = nextMaterial;
              const bsForMerge = colorOnlyUpdate ? { ...bs, description: null } : bs;
              const mergedBs = mergeBs5930(target.bs5930, bsForMerge);
              if (colorOnlyUpdate && bs.color) {
                mergedBs.color = bs.color;
                mergedBs.description = formatBS5930Description(mergedBs);
              }
              updated.bs5930 = mergedBs;
              updated.description = mergedBs.description || updated.description;
            }
            if (l.raw || entry.raw) updated.raw = l.raw || entry.raw;
            if (l.confidence != null) updated.confidence = l.confidence;
            if (l.inferred_from_context !== undefined) updated.inferred_from_context = l.inferred_from_context;
            updated.timestamp = entry.timestamp || entry.confirmed_at || updated.timestamp;
            state.log.strata[existingIndex] = updated;
            reconcileStrataBounds(state.log.strata, state.log.strata[existingIndex]);
            continue;
          }
        }
        const stratum = {
          id: "L" + (state.log.strata.length + 1),
          horizon_id: horizonId,
          from: l.from,
          to: l.to,
          material: l.material || bs.primary || "UNKNOWN",
          description: bs.description,
          bs5930: bs,
          raw: l.raw || entry.raw,
          confidence: l.confidence ?? null,
          inferred_from_context: l.inferred_from_context ?? false,
          timestamp: entry.timestamp || entry.confirmed_at
        };
        const inferred = inferLayerBounds(stratum, state.log);
        stratum.from = inferred.from;
        stratum.to = inferred.to;
        stratum.inferred_from_context = stratum.inferred_from_context || inferred.inferred;
        state.log.strata.push(stratum);
        reconcileStrataBounds(state.log.strata, stratum);
      }
    } else if (type === "sample") {
      const items = entry.parsed?.samples || (entry.parsed?.sample ? [entry.parsed.sample] : (entry.sample ? [entry.sample] : []));
      for (const s of items) {
        if (!s) continue;
        const sample = {
          id: s.id || ("S" + (state.log.samples.length + 1)),
          depth: s.depth ?? (s.to ?? s.from ?? null),
          from: s.from ?? null,
          to: s.to ?? null,
          type: s.type || null,
          raw: s.raw || entry.raw,
          timestamp: entry.timestamp || entry.confirmed_at
        };
        state.log.samples.push(sample);
      }
    } else if (type === "water") {
      const items = entry.parsed?.waters || (entry.parsed?.water ? [entry.parsed.water] : (entry.water ? [entry.water] : []));
      for (const w of items) {
        if (!w) continue;
        const water = {
          id: "W" + (state.log.water.length + 1),
          depth: w.depth ?? (w.to ?? w.from ?? null),
          from: w.from ?? null,
          to: w.to ?? null,
          condition: w.condition || null,
          remark: w.remark || null,
          time_minutes: w.time_minutes ?? null,
          raw: w.raw || entry.raw,
          timestamp: entry.timestamp || entry.confirmed_at
        };
        state.log.water.push(water);
      }
    } else if (type === "test") {
      const items = entry.parsed?.tests || (entry.parsed?.test ? [entry.parsed.test] : (entry.test ? [entry.test] : []));
      for (const t of items) {
        if (!t) continue;
        const test = {
          id: "T" + (state.log.tests.length + 1),
          depth: t.depth ?? (t.to ?? t.from ?? null),
          from: t.from ?? null,
          to: t.to ?? null,
          type: t.type || null,
          result: t.result || null,
          raw: t.raw || entry.raw,
          timestamp: entry.timestamp || entry.confirmed_at
        };
        state.log.tests.push(test);
      }
    } else if (type === "note") {
      const n = entry.parsed?.note || { text: entry.raw };
      state.log.notes.push({
        id: "N" + (state.log.notes.length + 1),
        text: n.text || entry.raw,
        raw: entry.raw,
        timestamp: entry.timestamp || entry.confirmed_at
      });
    }
  }

  // Confirm/export: confirm current entry and update the log
  function confirmEntry() {
    if (!state.current) return;

    const entry = {
      confirmed_at: new Date().toISOString(),
      ...state.current
    };

    if (state.editIndex !== null) {
      state.entries[state.editIndex] = entry;
      state.editIndex = null;
      setEditMode(false);
      rebuildLogFromEntries();
    } else {
      state.entries.push(entry);
      applyEntryToLog(entry);
    }
    $("entries").textContent = JSON.stringify(state.entries, null, 2);
    renderEntryList();
    renderLogData();
    renderLog();
    clearPendingFollowups();
    renderFollowups([]);
    $("btnExport").disabled = state.entries.length === 0;
    debug("Entry confirmed. Total entries: " + state.entries.length);
    schedulePersist("confirm");
    const transcript = $("txtTranscript");
    if (transcript) {
      transcript.value = "";
      transcript.focus();
    }
  }

  function exportJSON() {
    const payload = { entries: state.entries, log: state.log };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "voice-logging-log.json";
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    debug("Export triggered.");
  }

  // ---------------- Voice capture ----------------
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  let rec = null;
  let micStream = null;
  let audioCtx = null;
  let analyser = null;
  let analyserData = null;
  let meterRaf = null;
  let micTestActive = false;
  let speechResultTimer = null;
  let lastSpeechResultAt = null;
  let speechHadError = false;
  let mediaRecorder = null;
  let recordingChunks = [];
  let recordingStream = null;

  function stopMicMeter(resetStatus = true) {
    if (meterRaf) cancelAnimationFrame(meterRaf);
    meterRaf = null;
    analyserData = null;
    analyser = null;
    if (audioCtx) {
      audioCtx.close().catch(() => {});
      audioCtx = null;
    }
    if (micStream) {
      micStream.getTracks().forEach((t) => t.stop());
      micStream = null;
    }
    setMicLevel(0);
    if (resetStatus) setMicStatus("Mic: idle");
    micTestActive = false;
  }

  function startMicMeter(stream) {
    if (!stream) return;
    stopMicMeter();
    micStream = stream;
    try {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new Ctx();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      analyserData = new Uint8Array(analyser.fftSize);
      const source = audioCtx.createMediaStreamSource(stream);
      source.connect(analyser);
      audioCtx.resume().catch(() => {});
      const loop = () => {
        if (!analyser || !analyserData) return;
        analyser.getByteTimeDomainData(analyserData);
        let sum = 0;
        for (let i = 0; i < analyserData.length; i++) {
          const v = (analyserData[i] - 128) / 128;
          sum += v * v;
        }
        const rms = Math.sqrt(sum / analyserData.length);
        const pct = Math.min(100, Math.round(rms * 220));
        setMicLevel(pct);
        meterRaf = requestAnimationFrame(loop);
      };
      loop();
      setMicStatus("Mic: live");
    } catch (e) {
      debug("Mic meter failed: " + (e?.message || e));
      setMicStatus("Mic: meter error");
    }
  }

  async function preflightMicPermission(keepStream = false) {
    if (!navigator.mediaDevices?.getUserMedia) return { ok: false, reason: "getUserMedia unavailable" };
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      if (!keepStream) {
        stream.getTracks().forEach(t => t.stop());
        return { ok: true };
      }
      return { ok: true, stream };
    } catch (e) {
      return { ok: false, reason: e?.name || String(e) };
    }
  }

  function armSpeechWatchdog() {
    if (speechResultTimer) clearTimeout(speechResultTimer);
    lastSpeechResultAt = null;
    speechResultTimer = setTimeout(() => {
      if (!lastSpeechResultAt) {
        setDiag("No speech results received. Try Chrome/Edge and a secure context (https or http://localhost).");
        debug("Speech watchdog: no results.");
      }
    }, 6000);
  }

  function shouldAutoAnalyzeVoice() {
    const el = $("autoAnalyzeVoice");
    return Boolean(el && el.checked);
  }

  function maybeAutoAnalyzeVoice(trigger) {
    if (!shouldAutoAnalyzeVoice()) return;
    const raw = normalizeText($("txtTranscript").value);
    if (!raw) return;
    if (aiState.inFlight) return;
    debug("Auto-analyze after voice capture (" + trigger + ").");
    setTimeout(() => analyzeBest(), 50);
  }

  function setTranscribeStatus(msg) {
    const el = $("transcribeStatus");
    if (el) el.textContent = "Transcription: " + (msg || "");
  }

  function shouldUseOpenAiTranscription() {
    const el = $("useOpenAiTranscription");
    return Boolean(el && el.checked);
  }

  function getTranscribeModel() {
    const el = $("transcribeModel");
    return (el?.value || "gpt-4o-mini-transcribe").trim();
  }

  function getTranscribeApiKey() {
    return remoteState.apiKey || ($("remoteApiKey")?.value || "").trim();
  }

  function getTranscribeBase() {
    return normalizeApiBase($("remoteBase")?.value || remoteState.baseUrl);
  }

  function updateTranscribeStatus() {
    if (!shouldUseOpenAiTranscription()) {
      setTranscribeStatus("browser");
      return;
    }
    const model = getTranscribeModel();
    const key = getTranscribeApiKey();
    const suffix = key ? "" : " (missing key)";
    setTranscribeStatus("OpenAI " + model + suffix);
  }

  function pickRecorderMime() {
    if (typeof MediaRecorder === "undefined") return "";
    const types = [
      "audio/webm;codecs=opus",
      "audio/webm",
      "audio/ogg;codecs=opus",
      "audio/ogg",
      "audio/mp4"
    ];
    for (const t of types) {
      if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
    }
    return "";
  }

  function appendTranscriptText(text) {
    const el = $("txtTranscript");
    const existing = (el?.value || "").trim();
    const next = (text || "").trim();
    if (!next) return;
    el.value = (existing ? (existing + " " + next) : next).trim();
  }

  async function transcribeOpenAiAudio(blob) {
    const apiKey = getTranscribeApiKey();
    if (!apiKey) {
      setDiag("OpenAI transcription requires an API key.");
      setTranscribeStatus("needs key");
      return;
    }
    const base = getTranscribeBase();
    const url = /\/audio\/transcriptions$/i.test(base) ? base : (base + "/audio/transcriptions");
    const model = getTranscribeModel();
    setStatus("transcribing via OpenAI.");
    setTranscribeStatus("uploading");
    const form = new FormData();
    const ext = (blob.type && blob.type.includes("ogg")) ? "ogg" : (blob.type && blob.type.includes("mp4") ? "mp4" : "webm");
    const fileName = "voice." + ext;
    form.append("file", new File([blob], fileName, { type: blob.type || "audio/webm" }));
    form.append("model", model);

    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Authorization": "Bearer " + apiKey },
        body: form
      });
      const rawText = await res.text();
      let data = null;
      try {
        data = JSON.parse(rawText);
      } catch {
        data = null;
      }
      if (!res.ok) {
        const msg = data?.error?.message || rawText || res.statusText;
        throw new Error("Transcription error (" + res.status + "): " + msg);
      }
      const text = (data?.text || data?.transcription || "").trim();
      if (!text) throw new Error("Transcription returned no text.");
      appendTranscriptText(text);
      setStatus("idle");
      setTranscribeStatus("ready (" + model + ")");
      debug("OpenAI transcription completed: " + text.slice(0, 200));
      maybeAutoAnalyzeVoice("openai transcription");
    } catch (e) {
      const msg = e?.message || e;
      const hint = /failed to fetch|networkerror|cors/i.test(String(msg))
        ? " (check CORS or use a proxy server)."
        : "";
      setDiag("OpenAI transcription failed: " + msg + hint);
      setTranscribeStatus("error");
      setStatus("idle");
      debug("OpenAI transcription failed: " + msg);
    }
  }

  async function startOpenAiRecording() {
    if (typeof MediaRecorder === "undefined") {
      setDiag("MediaRecorder not supported in this browser.");
      return;
    }
    const apiKey = getTranscribeApiKey();
    if (!apiKey) {
      setDiag("OpenAI transcription requires an API key.");
      updateTranscribeStatus();
      return;
    }
    setStatus("requesting mic permission.");
    setMicStatus("Mic: requesting permission");
    const mic = await preflightMicPermission(true);
    if (!mic.ok) {
      setStatus("mic blocked");
      setDiag("Microphone permission failed (" + mic.reason + "). If you opened via file://, try http://localhost.");
      debug("Mic permission failed: " + mic.reason);
      setMicStatus("Mic: blocked");
      return;
    }
    if (micTestActive) {
      stopMicMeter(false);
      $("btnMicTest").textContent = "Mic test";
    }
    recordingStream = mic.stream;
    startMicMeter(recordingStream);
    const mimeType = pickRecorderMime();
    recordingChunks = [];
    try {
      mediaRecorder = new MediaRecorder(recordingStream, mimeType ? { mimeType } : undefined);
    } catch (e) {
      setDiag("Recorder failed: " + (e?.message || e));
      stopMicMeter();
      recordingStream = null;
      return;
    }
    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size) recordingChunks.push(e.data);
    };
    mediaRecorder.onerror = (e) => {
      setDiag("Recorder error: " + (e?.error?.message || e?.message || e));
      debug("Recorder error: " + (e?.error?.message || e?.message || e));
    };
    mediaRecorder.onstart = () => {
      setStatus("recording.");
      setMicStatus("Mic: recording");
      setMicLevel(40);
      setTranscribeStatus("recording");
      debug("Recorder started.");
    };
    mediaRecorder.onstop = async () => {
      debug("Recorder stopped.");
      const blob = new Blob(recordingChunks, { type: mimeType || "audio/webm" });
      stopMicMeter();
      recordingStream = null;
      recordingChunks = [];
      mediaRecorder = null;
      await transcribeOpenAiAudio(blob);
    };
    mediaRecorder.start();
    $("btnStart").disabled = true;
    $("btnStop").disabled = false;
  }

  function stopOpenAiRecording() {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      setStatus("processing audio.");
      setMicStatus("Mic: processing");
      mediaRecorder.stop();
    } else {
      stopMicMeter();
    }
    $("btnStart").disabled = false;
    $("btnStop").disabled = true;
    $("btnMicTest").textContent = "Mic test";
  }

  async function toggleMicTest() {
    if (micTestActive) {
      stopMicMeter();
      $("btnMicTest").textContent = "Mic test";
      return;
    }
    setMicStatus("Mic: testing");
    const mic = await preflightMicPermission(true);
    if (!mic.ok) {
      setMicStatus("Mic: blocked");
      setDiag("Microphone permission failed (" + mic.reason + ").");
      debug("Mic test failed: " + mic.reason);
      return;
    }
    startMicMeter(mic.stream);
    micTestActive = true;
    $("btnMicTest").textContent = "Stop mic";
  }

  function setupRecognizer() {
    const r = new SpeechRecognition();
    r.lang = "en-GB";
    r.continuous = true;
    r.interimResults = true;
    r.maxAlternatives = 1;
    return r;
  }

  async function startVoice() {
    setDiag("");
    debug("Start voice clicked.");
    if (shouldUseOpenAiTranscription()) {
      updateTranscribeStatus();
      await startOpenAiRecording();
      return;
    }
    if (!SpeechRecognition) {
      setStatus("Voice not supported");
      setDiag("SpeechRecognition API not available in this browser.");
      debug("SpeechRecognition not available.");
      setMicStatus("Mic: unsupported");
      return;
    }
    setStatus("requesting mic permission.");
    setMicStatus("Mic: requesting permission");
    const mic = await preflightMicPermission();
    if (!mic.ok) {
      setStatus("mic blocked");
      setDiag("Microphone permission failed (" + mic.reason + "). If you opened via file://, try http://localhost.");
      debug("Mic permission failed: " + mic.reason);
      setMicStatus("Mic: blocked");
      return;
    }
    if (micTestActive) {
      stopMicMeter(false);
      $("btnMicTest").textContent = "Mic test";
    }
    setStatus("starting recognition.");
    setMicStatus("Mic: starting recognition");
    setMicLevel(10);
    if (!rec) rec = setupRecognizer();
    speechHadError = false;

    let finalText = $("txtTranscript").value.trim();
    rec.onresult = (event) => {
      let interim = "";
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        if (res.isFinal) {
          finalText += (finalText ? " " : "") + res[0].transcript.trim();
          debug("Speech final: " + res[0].transcript.trim());
        }
        else interim += res[0].transcript;
      }
      lastSpeechResultAt = Date.now();
      if (speechResultTimer) {
        clearTimeout(speechResultTimer);
        speechResultTimer = null;
      }
      $("txtTranscript").value = (finalText + (interim ? " " + interim.trim() : "")).trim();
    };
    rec.onstart = () => { setStatus("listening."); setMicStatus("Mic: listening"); setMicLevel(20); debug("Speech started."); };
    rec.onaudiostart = () => { setMicStatus("Mic: audio detected"); setMicLevel(30); debug("Speech audio start."); };
    rec.onsoundstart = () => { setMicStatus("Mic: sound detected"); setMicLevel(40); debug("Speech sound start."); };
    rec.onspeechstart = () => { setMicStatus("Mic: speech detected"); setMicLevel(80); debug("Speech speech start."); };
    rec.onspeechend = () => { setMicStatus("Mic: speech ended"); setMicLevel(30); debug("Speech speech end."); };
    rec.onaudioend = () => { setMicStatus("Mic: audio ended"); setMicLevel(10); debug("Speech audio end."); };
    rec.onerror = (e) => {
      speechHadError = true;
      setStatus("Voice error: " + (e.error || "unknown"));
      setDiag("Speech error: " + (e.error || "unknown"));
      debug("Speech error: " + (e.error || "unknown"));
    };
    rec.onend = () => {
      $("btnStart").disabled = false;
      $("btnStop").disabled = true;
      setStatus("idle");
      stopMicMeter();
      if (speechResultTimer) {
        clearTimeout(speechResultTimer);
        speechResultTimer = null;
      }
      debug("Speech ended.");
      if (!speechHadError) maybeAutoAnalyzeVoice("speech end");
      speechHadError = false;
    };

    $("btnStart").disabled = true;
    $("btnStop").disabled = false;
    try {
      armSpeechWatchdog();
      rec.start();
    } catch (e) {
      $("btnStart").disabled = false;
      $("btnStop").disabled = true;
      setStatus("could not start");
      setDiag("rec.start() failed (" + (e?.name || e) + ").");
      debug("rec.start() failed: " + (e?.name || e));
      if (speechResultTimer) {
        clearTimeout(speechResultTimer);
        speechResultTimer = null;
      }
      stopMicMeter();
    }
  }

  function stopVoice() {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      stopOpenAiRecording();
      return;
    }
    if (shouldUseOpenAiTranscription() && recordingStream) {
      stopOpenAiRecording();
      return;
    }
    if (rec) rec.stop();
    if (speechResultTimer) {
      clearTimeout(speechResultTimer);
      speechResultTimer = null;
    }
    stopMicMeter();
    $("btnMicTest").textContent = "Mic test";
    debug("Stop voice clicked.");
  }

  function clearAll() {
    $("txtTranscript").value = "";
    $("out").textContent = "{}";
    $("pills").innerHTML = "";
    $("prompts").innerHTML = "";
    clearPendingFollowups();
    renderFollowups([]);
    clearChat();
    const review = $("review");
    if (review) {
      review.textContent = "Nothing to review yet.";
      review.className = "review-muted";
    }
    $("btnConfirm").disabled = true;
    state.current = null;
    state.editIndex = null;
    setEditMode(false);
    setDiag("");
    setStatus("idle");
    renderLogData();
    renderLog();
    debug("Cleared.");
  }

  // ---------------- Wire up ----------------
  function wire() {
    debug("Wiring events");
    $("btnStart").addEventListener("click", startVoice);
    $("btnStop").addEventListener("click", stopVoice);
    $("btnMicTest").addEventListener("click", toggleMicTest);
    $("btnAnalyze").addEventListener("click", analyzeBest);
    $("btnConfirm").addEventListener("click", confirmEntry);
    $("btnExport").addEventListener("click", exportJSON);
    $("btnClear").addEventListener("click", clearAll);
    $("btnClearDb").addEventListener("click", clearDatabase);
    $("btnCancelAI").addEventListener("click", () => cancelAiRun("AI: canceled"));
    $("btnCancelEdit").addEventListener("click", () => {
      state.editIndex = null;
      setEditMode(false);
      setDiag("");
      renderReview(state.current?.parsed || null);
    });

    $("btnEnableRemote").addEventListener("click", enableRemote);
    $("btnDisableRemote").addEventListener("click", disableRemote);
    const remoteModelEl = $("remoteModel");
    if (remoteModelEl) remoteModelEl.value = remoteState.model;
    $("remoteModel").addEventListener("change", (e) => {
      remoteState.model = (e.target.value || remoteState.model).trim();
      if (remoteState.enabled) setRemoteStatus("enabled (" + remoteState.model + ")");
    });
    $("remoteBase").addEventListener("input", (e) => {
      remoteState.baseUrl = normalizeApiBase(e.target.value) || remoteState.baseUrl;
    });
    $("remoteApiKey").addEventListener("input", updateTranscribeStatus);
    $("useOpenAiTranscription").addEventListener("change", updateTranscribeStatus);
    $("transcribeModel").addEventListener("change", updateTranscribeStatus);
    $("holeId").value = state.log.hole_id;
    $("holeId").addEventListener("input", (e) => {
      state.log.hole_id = normalizeText(e.target.value) || "EH1";
      renderLogData();
      renderLog();
      schedulePersist("hole id");
    });

    debug("Wired. Ready.");
    setStatus("idle");
    updateTranscribeStatus();
    restoreStateFromStorage().finally(() => {
      $("holeId").value = state.log.hole_id || "EH1";
      $("entries").textContent = JSON.stringify(state.entries, null, 2);
      $("btnExport").disabled = state.entries.length === 0;
      renderLogData();
      renderLog();
      renderEntryList();
      clearPendingFollowups();
      renderFollowups([]);
      renderChat();
    });

  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", wire);
  else wire();
</script>
</body>
</html>







